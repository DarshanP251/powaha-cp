
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model community_partners
 * 
 */
export type community_partners = $Result.DefaultSelection<Prisma.$community_partnersPayload>
/**
 * Model cp_applications
 * 
 */
export type cp_applications = $Result.DefaultSelection<Prisma.$cp_applicationsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model cp_leads
 * 
 */
export type cp_leads = $Result.DefaultSelection<Prisma.$cp_leadsPayload>
/**
 * Model incentives
 * 
 */
export type incentives = $Result.DefaultSelection<Prisma.$incentivesPayload>
/**
 * Model incentive_config
 * 
 */
export type incentive_config = $Result.DefaultSelection<Prisma.$incentive_configPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CpStatus: {
  APPLIED: 'APPLIED',
  ACTIVE: 'ACTIVE',
  REJECTED: 'REJECTED'
};

export type CpStatus = (typeof CpStatus)[keyof typeof CpStatus]


export const CpApplicationStatus: {
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type CpApplicationStatus = (typeof CpApplicationStatus)[keyof typeof CpApplicationStatus]

}

export type CpStatus = $Enums.CpStatus

export const CpStatus: typeof $Enums.CpStatus

export type CpApplicationStatus = $Enums.CpApplicationStatus

export const CpApplicationStatus: typeof $Enums.CpApplicationStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Community_partners
 * const community_partners = await prisma.community_partners.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Community_partners
   * const community_partners = await prisma.community_partners.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.community_partners`: Exposes CRUD operations for the **community_partners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Community_partners
    * const community_partners = await prisma.community_partners.findMany()
    * ```
    */
  get community_partners(): Prisma.community_partnersDelegate<ExtArgs>;

  /**
   * `prisma.cp_applications`: Exposes CRUD operations for the **cp_applications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cp_applications
    * const cp_applications = await prisma.cp_applications.findMany()
    * ```
    */
  get cp_applications(): Prisma.cp_applicationsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.cp_leads`: Exposes CRUD operations for the **cp_leads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cp_leads
    * const cp_leads = await prisma.cp_leads.findMany()
    * ```
    */
  get cp_leads(): Prisma.cp_leadsDelegate<ExtArgs>;

  /**
   * `prisma.incentives`: Exposes CRUD operations for the **incentives** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incentives
    * const incentives = await prisma.incentives.findMany()
    * ```
    */
  get incentives(): Prisma.incentivesDelegate<ExtArgs>;

  /**
   * `prisma.incentive_config`: Exposes CRUD operations for the **incentive_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incentive_configs
    * const incentive_configs = await prisma.incentive_config.findMany()
    * ```
    */
  get incentive_config(): Prisma.incentive_configDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    community_partners: 'community_partners',
    cp_applications: 'cp_applications',
    users: 'users',
    cp_leads: 'cp_leads',
    incentives: 'incentives',
    incentive_config: 'incentive_config'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "community_partners" | "cp_applications" | "users" | "cp_leads" | "incentives" | "incentive_config"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      community_partners: {
        payload: Prisma.$community_partnersPayload<ExtArgs>
        fields: Prisma.community_partnersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.community_partnersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.community_partnersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>
          }
          findFirst: {
            args: Prisma.community_partnersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.community_partnersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>
          }
          findMany: {
            args: Prisma.community_partnersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>[]
          }
          create: {
            args: Prisma.community_partnersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>
          }
          createMany: {
            args: Prisma.community_partnersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.community_partnersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>[]
          }
          delete: {
            args: Prisma.community_partnersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>
          }
          update: {
            args: Prisma.community_partnersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>
          }
          deleteMany: {
            args: Prisma.community_partnersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.community_partnersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.community_partnersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$community_partnersPayload>
          }
          aggregate: {
            args: Prisma.Community_partnersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunity_partners>
          }
          groupBy: {
            args: Prisma.community_partnersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Community_partnersGroupByOutputType>[]
          }
          count: {
            args: Prisma.community_partnersCountArgs<ExtArgs>
            result: $Utils.Optional<Community_partnersCountAggregateOutputType> | number
          }
        }
      }
      cp_applications: {
        payload: Prisma.$cp_applicationsPayload<ExtArgs>
        fields: Prisma.cp_applicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cp_applicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cp_applicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>
          }
          findFirst: {
            args: Prisma.cp_applicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cp_applicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>
          }
          findMany: {
            args: Prisma.cp_applicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>[]
          }
          create: {
            args: Prisma.cp_applicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>
          }
          createMany: {
            args: Prisma.cp_applicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cp_applicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>[]
          }
          delete: {
            args: Prisma.cp_applicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>
          }
          update: {
            args: Prisma.cp_applicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>
          }
          deleteMany: {
            args: Prisma.cp_applicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cp_applicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cp_applicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_applicationsPayload>
          }
          aggregate: {
            args: Prisma.Cp_applicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCp_applications>
          }
          groupBy: {
            args: Prisma.cp_applicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cp_applicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cp_applicationsCountArgs<ExtArgs>
            result: $Utils.Optional<Cp_applicationsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      cp_leads: {
        payload: Prisma.$cp_leadsPayload<ExtArgs>
        fields: Prisma.cp_leadsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cp_leadsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cp_leadsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>
          }
          findFirst: {
            args: Prisma.cp_leadsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cp_leadsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>
          }
          findMany: {
            args: Prisma.cp_leadsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>[]
          }
          create: {
            args: Prisma.cp_leadsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>
          }
          createMany: {
            args: Prisma.cp_leadsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cp_leadsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>[]
          }
          delete: {
            args: Prisma.cp_leadsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>
          }
          update: {
            args: Prisma.cp_leadsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>
          }
          deleteMany: {
            args: Prisma.cp_leadsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cp_leadsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cp_leadsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cp_leadsPayload>
          }
          aggregate: {
            args: Prisma.Cp_leadsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCp_leads>
          }
          groupBy: {
            args: Prisma.cp_leadsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cp_leadsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cp_leadsCountArgs<ExtArgs>
            result: $Utils.Optional<Cp_leadsCountAggregateOutputType> | number
          }
        }
      }
      incentives: {
        payload: Prisma.$incentivesPayload<ExtArgs>
        fields: Prisma.incentivesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.incentivesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.incentivesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>
          }
          findFirst: {
            args: Prisma.incentivesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.incentivesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>
          }
          findMany: {
            args: Prisma.incentivesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>[]
          }
          create: {
            args: Prisma.incentivesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>
          }
          createMany: {
            args: Prisma.incentivesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.incentivesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>[]
          }
          delete: {
            args: Prisma.incentivesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>
          }
          update: {
            args: Prisma.incentivesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>
          }
          deleteMany: {
            args: Prisma.incentivesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.incentivesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.incentivesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentivesPayload>
          }
          aggregate: {
            args: Prisma.IncentivesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncentives>
          }
          groupBy: {
            args: Prisma.incentivesGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncentivesGroupByOutputType>[]
          }
          count: {
            args: Prisma.incentivesCountArgs<ExtArgs>
            result: $Utils.Optional<IncentivesCountAggregateOutputType> | number
          }
        }
      }
      incentive_config: {
        payload: Prisma.$incentive_configPayload<ExtArgs>
        fields: Prisma.incentive_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.incentive_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.incentive_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>
          }
          findFirst: {
            args: Prisma.incentive_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.incentive_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>
          }
          findMany: {
            args: Prisma.incentive_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>[]
          }
          create: {
            args: Prisma.incentive_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>
          }
          createMany: {
            args: Prisma.incentive_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.incentive_configCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>[]
          }
          delete: {
            args: Prisma.incentive_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>
          }
          update: {
            args: Prisma.incentive_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>
          }
          deleteMany: {
            args: Prisma.incentive_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.incentive_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.incentive_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$incentive_configPayload>
          }
          aggregate: {
            args: Prisma.Incentive_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncentive_config>
          }
          groupBy: {
            args: Prisma.incentive_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Incentive_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.incentive_configCountArgs<ExtArgs>
            result: $Utils.Optional<Incentive_configCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Community_partnersCountOutputType
   */

  export type Community_partnersCountOutputType = {
    cp_applications: number
  }

  export type Community_partnersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cp_applications?: boolean | Community_partnersCountOutputTypeCountCp_applicationsArgs
  }

  // Custom InputTypes
  /**
   * Community_partnersCountOutputType without action
   */
  export type Community_partnersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community_partnersCountOutputType
     */
    select?: Community_partnersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Community_partnersCountOutputType without action
   */
  export type Community_partnersCountOutputTypeCountCp_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cp_applicationsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model community_partners
   */

  export type AggregateCommunity_partners = {
    _count: Community_partnersCountAggregateOutputType | null
    _min: Community_partnersMinAggregateOutputType | null
    _max: Community_partnersMaxAggregateOutputType | null
  }

  export type Community_partnersMinAggregateOutputType = {
    cp_id: string | null
    name: string | null
    email: string | null
    mobile: string | null
    status: $Enums.CpStatus | null
    created_at: Date | null
  }

  export type Community_partnersMaxAggregateOutputType = {
    cp_id: string | null
    name: string | null
    email: string | null
    mobile: string | null
    status: $Enums.CpStatus | null
    created_at: Date | null
  }

  export type Community_partnersCountAggregateOutputType = {
    cp_id: number
    name: number
    email: number
    mobile: number
    status: number
    aoo: number
    created_at: number
    _all: number
  }


  export type Community_partnersMinAggregateInputType = {
    cp_id?: true
    name?: true
    email?: true
    mobile?: true
    status?: true
    created_at?: true
  }

  export type Community_partnersMaxAggregateInputType = {
    cp_id?: true
    name?: true
    email?: true
    mobile?: true
    status?: true
    created_at?: true
  }

  export type Community_partnersCountAggregateInputType = {
    cp_id?: true
    name?: true
    email?: true
    mobile?: true
    status?: true
    aoo?: true
    created_at?: true
    _all?: true
  }

  export type Community_partnersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which community_partners to aggregate.
     */
    where?: community_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of community_partners to fetch.
     */
    orderBy?: community_partnersOrderByWithRelationInput | community_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: community_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` community_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` community_partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned community_partners
    **/
    _count?: true | Community_partnersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Community_partnersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Community_partnersMaxAggregateInputType
  }

  export type GetCommunity_partnersAggregateType<T extends Community_partnersAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity_partners]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity_partners[P]>
      : GetScalarType<T[P], AggregateCommunity_partners[P]>
  }




  export type community_partnersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: community_partnersWhereInput
    orderBy?: community_partnersOrderByWithAggregationInput | community_partnersOrderByWithAggregationInput[]
    by: Community_partnersScalarFieldEnum[] | Community_partnersScalarFieldEnum
    having?: community_partnersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Community_partnersCountAggregateInputType | true
    _min?: Community_partnersMinAggregateInputType
    _max?: Community_partnersMaxAggregateInputType
  }

  export type Community_partnersGroupByOutputType = {
    cp_id: string
    name: string
    email: string
    mobile: string
    status: $Enums.CpStatus
    aoo: JsonValue | null
    created_at: Date
    _count: Community_partnersCountAggregateOutputType | null
    _min: Community_partnersMinAggregateOutputType | null
    _max: Community_partnersMaxAggregateOutputType | null
  }

  type GetCommunity_partnersGroupByPayload<T extends community_partnersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Community_partnersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Community_partnersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Community_partnersGroupByOutputType[P]>
            : GetScalarType<T[P], Community_partnersGroupByOutputType[P]>
        }
      >
    >


  export type community_partnersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cp_id?: boolean
    name?: boolean
    email?: boolean
    mobile?: boolean
    status?: boolean
    aoo?: boolean
    created_at?: boolean
    cp_applications?: boolean | community_partners$cp_applicationsArgs<ExtArgs>
    _count?: boolean | Community_partnersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community_partners"]>

  export type community_partnersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cp_id?: boolean
    name?: boolean
    email?: boolean
    mobile?: boolean
    status?: boolean
    aoo?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["community_partners"]>

  export type community_partnersSelectScalar = {
    cp_id?: boolean
    name?: boolean
    email?: boolean
    mobile?: boolean
    status?: boolean
    aoo?: boolean
    created_at?: boolean
  }

  export type community_partnersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cp_applications?: boolean | community_partners$cp_applicationsArgs<ExtArgs>
    _count?: boolean | Community_partnersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type community_partnersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $community_partnersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "community_partners"
    objects: {
      cp_applications: Prisma.$cp_applicationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cp_id: string
      name: string
      email: string
      mobile: string
      status: $Enums.CpStatus
      aoo: Prisma.JsonValue | null
      created_at: Date
    }, ExtArgs["result"]["community_partners"]>
    composites: {}
  }

  type community_partnersGetPayload<S extends boolean | null | undefined | community_partnersDefaultArgs> = $Result.GetResult<Prisma.$community_partnersPayload, S>

  type community_partnersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<community_partnersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Community_partnersCountAggregateInputType | true
    }

  export interface community_partnersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['community_partners'], meta: { name: 'community_partners' } }
    /**
     * Find zero or one Community_partners that matches the filter.
     * @param {community_partnersFindUniqueArgs} args - Arguments to find a Community_partners
     * @example
     * // Get one Community_partners
     * const community_partners = await prisma.community_partners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends community_partnersFindUniqueArgs>(args: SelectSubset<T, community_partnersFindUniqueArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Community_partners that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {community_partnersFindUniqueOrThrowArgs} args - Arguments to find a Community_partners
     * @example
     * // Get one Community_partners
     * const community_partners = await prisma.community_partners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends community_partnersFindUniqueOrThrowArgs>(args: SelectSubset<T, community_partnersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Community_partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {community_partnersFindFirstArgs} args - Arguments to find a Community_partners
     * @example
     * // Get one Community_partners
     * const community_partners = await prisma.community_partners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends community_partnersFindFirstArgs>(args?: SelectSubset<T, community_partnersFindFirstArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Community_partners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {community_partnersFindFirstOrThrowArgs} args - Arguments to find a Community_partners
     * @example
     * // Get one Community_partners
     * const community_partners = await prisma.community_partners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends community_partnersFindFirstOrThrowArgs>(args?: SelectSubset<T, community_partnersFindFirstOrThrowArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Community_partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {community_partnersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Community_partners
     * const community_partners = await prisma.community_partners.findMany()
     * 
     * // Get first 10 Community_partners
     * const community_partners = await prisma.community_partners.findMany({ take: 10 })
     * 
     * // Only select the `cp_id`
     * const community_partnersWithCp_idOnly = await prisma.community_partners.findMany({ select: { cp_id: true } })
     * 
     */
    findMany<T extends community_partnersFindManyArgs>(args?: SelectSubset<T, community_partnersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Community_partners.
     * @param {community_partnersCreateArgs} args - Arguments to create a Community_partners.
     * @example
     * // Create one Community_partners
     * const Community_partners = await prisma.community_partners.create({
     *   data: {
     *     // ... data to create a Community_partners
     *   }
     * })
     * 
     */
    create<T extends community_partnersCreateArgs>(args: SelectSubset<T, community_partnersCreateArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Community_partners.
     * @param {community_partnersCreateManyArgs} args - Arguments to create many Community_partners.
     * @example
     * // Create many Community_partners
     * const community_partners = await prisma.community_partners.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends community_partnersCreateManyArgs>(args?: SelectSubset<T, community_partnersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Community_partners and returns the data saved in the database.
     * @param {community_partnersCreateManyAndReturnArgs} args - Arguments to create many Community_partners.
     * @example
     * // Create many Community_partners
     * const community_partners = await prisma.community_partners.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Community_partners and only return the `cp_id`
     * const community_partnersWithCp_idOnly = await prisma.community_partners.createManyAndReturn({ 
     *   select: { cp_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends community_partnersCreateManyAndReturnArgs>(args?: SelectSubset<T, community_partnersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Community_partners.
     * @param {community_partnersDeleteArgs} args - Arguments to delete one Community_partners.
     * @example
     * // Delete one Community_partners
     * const Community_partners = await prisma.community_partners.delete({
     *   where: {
     *     // ... filter to delete one Community_partners
     *   }
     * })
     * 
     */
    delete<T extends community_partnersDeleteArgs>(args: SelectSubset<T, community_partnersDeleteArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Community_partners.
     * @param {community_partnersUpdateArgs} args - Arguments to update one Community_partners.
     * @example
     * // Update one Community_partners
     * const community_partners = await prisma.community_partners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends community_partnersUpdateArgs>(args: SelectSubset<T, community_partnersUpdateArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Community_partners.
     * @param {community_partnersDeleteManyArgs} args - Arguments to filter Community_partners to delete.
     * @example
     * // Delete a few Community_partners
     * const { count } = await prisma.community_partners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends community_partnersDeleteManyArgs>(args?: SelectSubset<T, community_partnersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Community_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {community_partnersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Community_partners
     * const community_partners = await prisma.community_partners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends community_partnersUpdateManyArgs>(args: SelectSubset<T, community_partnersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Community_partners.
     * @param {community_partnersUpsertArgs} args - Arguments to update or create a Community_partners.
     * @example
     * // Update or create a Community_partners
     * const community_partners = await prisma.community_partners.upsert({
     *   create: {
     *     // ... data to create a Community_partners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community_partners we want to update
     *   }
     * })
     */
    upsert<T extends community_partnersUpsertArgs>(args: SelectSubset<T, community_partnersUpsertArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Community_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {community_partnersCountArgs} args - Arguments to filter Community_partners to count.
     * @example
     * // Count the number of Community_partners
     * const count = await prisma.community_partners.count({
     *   where: {
     *     // ... the filter for the Community_partners we want to count
     *   }
     * })
    **/
    count<T extends community_partnersCountArgs>(
      args?: Subset<T, community_partnersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Community_partnersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Community_partnersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Community_partnersAggregateArgs>(args: Subset<T, Community_partnersAggregateArgs>): Prisma.PrismaPromise<GetCommunity_partnersAggregateType<T>>

    /**
     * Group by Community_partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {community_partnersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends community_partnersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: community_partnersGroupByArgs['orderBy'] }
        : { orderBy?: community_partnersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, community_partnersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunity_partnersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the community_partners model
   */
  readonly fields: community_partnersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for community_partners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__community_partnersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cp_applications<T extends community_partners$cp_applicationsArgs<ExtArgs> = {}>(args?: Subset<T, community_partners$cp_applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the community_partners model
   */ 
  interface community_partnersFieldRefs {
    readonly cp_id: FieldRef<"community_partners", 'String'>
    readonly name: FieldRef<"community_partners", 'String'>
    readonly email: FieldRef<"community_partners", 'String'>
    readonly mobile: FieldRef<"community_partners", 'String'>
    readonly status: FieldRef<"community_partners", 'CpStatus'>
    readonly aoo: FieldRef<"community_partners", 'Json'>
    readonly created_at: FieldRef<"community_partners", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * community_partners findUnique
   */
  export type community_partnersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * Filter, which community_partners to fetch.
     */
    where: community_partnersWhereUniqueInput
  }

  /**
   * community_partners findUniqueOrThrow
   */
  export type community_partnersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * Filter, which community_partners to fetch.
     */
    where: community_partnersWhereUniqueInput
  }

  /**
   * community_partners findFirst
   */
  export type community_partnersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * Filter, which community_partners to fetch.
     */
    where?: community_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of community_partners to fetch.
     */
    orderBy?: community_partnersOrderByWithRelationInput | community_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for community_partners.
     */
    cursor?: community_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` community_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` community_partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of community_partners.
     */
    distinct?: Community_partnersScalarFieldEnum | Community_partnersScalarFieldEnum[]
  }

  /**
   * community_partners findFirstOrThrow
   */
  export type community_partnersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * Filter, which community_partners to fetch.
     */
    where?: community_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of community_partners to fetch.
     */
    orderBy?: community_partnersOrderByWithRelationInput | community_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for community_partners.
     */
    cursor?: community_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` community_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` community_partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of community_partners.
     */
    distinct?: Community_partnersScalarFieldEnum | Community_partnersScalarFieldEnum[]
  }

  /**
   * community_partners findMany
   */
  export type community_partnersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * Filter, which community_partners to fetch.
     */
    where?: community_partnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of community_partners to fetch.
     */
    orderBy?: community_partnersOrderByWithRelationInput | community_partnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing community_partners.
     */
    cursor?: community_partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` community_partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` community_partners.
     */
    skip?: number
    distinct?: Community_partnersScalarFieldEnum | Community_partnersScalarFieldEnum[]
  }

  /**
   * community_partners create
   */
  export type community_partnersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * The data needed to create a community_partners.
     */
    data: XOR<community_partnersCreateInput, community_partnersUncheckedCreateInput>
  }

  /**
   * community_partners createMany
   */
  export type community_partnersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many community_partners.
     */
    data: community_partnersCreateManyInput | community_partnersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * community_partners createManyAndReturn
   */
  export type community_partnersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many community_partners.
     */
    data: community_partnersCreateManyInput | community_partnersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * community_partners update
   */
  export type community_partnersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * The data needed to update a community_partners.
     */
    data: XOR<community_partnersUpdateInput, community_partnersUncheckedUpdateInput>
    /**
     * Choose, which community_partners to update.
     */
    where: community_partnersWhereUniqueInput
  }

  /**
   * community_partners updateMany
   */
  export type community_partnersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update community_partners.
     */
    data: XOR<community_partnersUpdateManyMutationInput, community_partnersUncheckedUpdateManyInput>
    /**
     * Filter which community_partners to update
     */
    where?: community_partnersWhereInput
  }

  /**
   * community_partners upsert
   */
  export type community_partnersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * The filter to search for the community_partners to update in case it exists.
     */
    where: community_partnersWhereUniqueInput
    /**
     * In case the community_partners found by the `where` argument doesn't exist, create a new community_partners with this data.
     */
    create: XOR<community_partnersCreateInput, community_partnersUncheckedCreateInput>
    /**
     * In case the community_partners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<community_partnersUpdateInput, community_partnersUncheckedUpdateInput>
  }

  /**
   * community_partners delete
   */
  export type community_partnersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
    /**
     * Filter which community_partners to delete.
     */
    where: community_partnersWhereUniqueInput
  }

  /**
   * community_partners deleteMany
   */
  export type community_partnersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which community_partners to delete
     */
    where?: community_partnersWhereInput
  }

  /**
   * community_partners.cp_applications
   */
  export type community_partners$cp_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    where?: cp_applicationsWhereInput
    orderBy?: cp_applicationsOrderByWithRelationInput | cp_applicationsOrderByWithRelationInput[]
    cursor?: cp_applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cp_applicationsScalarFieldEnum | Cp_applicationsScalarFieldEnum[]
  }

  /**
   * community_partners without action
   */
  export type community_partnersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the community_partners
     */
    select?: community_partnersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: community_partnersInclude<ExtArgs> | null
  }


  /**
   * Model cp_applications
   */

  export type AggregateCp_applications = {
    _count: Cp_applicationsCountAggregateOutputType | null
    _min: Cp_applicationsMinAggregateOutputType | null
    _max: Cp_applicationsMaxAggregateOutputType | null
  }

  export type Cp_applicationsMinAggregateOutputType = {
    application_id: string | null
    cp_id: string | null
    status: $Enums.CpApplicationStatus | null
    reviewed_by: string | null
    reviewed_at: Date | null
    created_at: Date | null
  }

  export type Cp_applicationsMaxAggregateOutputType = {
    application_id: string | null
    cp_id: string | null
    status: $Enums.CpApplicationStatus | null
    reviewed_by: string | null
    reviewed_at: Date | null
    created_at: Date | null
  }

  export type Cp_applicationsCountAggregateOutputType = {
    application_id: number
    cp_id: number
    application_data: number
    status: number
    reviewed_by: number
    reviewed_at: number
    created_at: number
    _all: number
  }


  export type Cp_applicationsMinAggregateInputType = {
    application_id?: true
    cp_id?: true
    status?: true
    reviewed_by?: true
    reviewed_at?: true
    created_at?: true
  }

  export type Cp_applicationsMaxAggregateInputType = {
    application_id?: true
    cp_id?: true
    status?: true
    reviewed_by?: true
    reviewed_at?: true
    created_at?: true
  }

  export type Cp_applicationsCountAggregateInputType = {
    application_id?: true
    cp_id?: true
    application_data?: true
    status?: true
    reviewed_by?: true
    reviewed_at?: true
    created_at?: true
    _all?: true
  }

  export type Cp_applicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cp_applications to aggregate.
     */
    where?: cp_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_applications to fetch.
     */
    orderBy?: cp_applicationsOrderByWithRelationInput | cp_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cp_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cp_applications
    **/
    _count?: true | Cp_applicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cp_applicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cp_applicationsMaxAggregateInputType
  }

  export type GetCp_applicationsAggregateType<T extends Cp_applicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCp_applications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCp_applications[P]>
      : GetScalarType<T[P], AggregateCp_applications[P]>
  }




  export type cp_applicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cp_applicationsWhereInput
    orderBy?: cp_applicationsOrderByWithAggregationInput | cp_applicationsOrderByWithAggregationInput[]
    by: Cp_applicationsScalarFieldEnum[] | Cp_applicationsScalarFieldEnum
    having?: cp_applicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cp_applicationsCountAggregateInputType | true
    _min?: Cp_applicationsMinAggregateInputType
    _max?: Cp_applicationsMaxAggregateInputType
  }

  export type Cp_applicationsGroupByOutputType = {
    application_id: string
    cp_id: string
    application_data: JsonValue
    status: $Enums.CpApplicationStatus
    reviewed_by: string | null
    reviewed_at: Date | null
    created_at: Date
    _count: Cp_applicationsCountAggregateOutputType | null
    _min: Cp_applicationsMinAggregateOutputType | null
    _max: Cp_applicationsMaxAggregateOutputType | null
  }

  type GetCp_applicationsGroupByPayload<T extends cp_applicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cp_applicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cp_applicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cp_applicationsGroupByOutputType[P]>
            : GetScalarType<T[P], Cp_applicationsGroupByOutputType[P]>
        }
      >
    >


  export type cp_applicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    cp_id?: boolean
    application_data?: boolean
    status?: boolean
    reviewed_by?: boolean
    reviewed_at?: boolean
    created_at?: boolean
    cp?: boolean | community_partnersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cp_applications"]>

  export type cp_applicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    cp_id?: boolean
    application_data?: boolean
    status?: boolean
    reviewed_by?: boolean
    reviewed_at?: boolean
    created_at?: boolean
    cp?: boolean | community_partnersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cp_applications"]>

  export type cp_applicationsSelectScalar = {
    application_id?: boolean
    cp_id?: boolean
    application_data?: boolean
    status?: boolean
    reviewed_by?: boolean
    reviewed_at?: boolean
    created_at?: boolean
  }

  export type cp_applicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cp?: boolean | community_partnersDefaultArgs<ExtArgs>
  }
  export type cp_applicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cp?: boolean | community_partnersDefaultArgs<ExtArgs>
  }

  export type $cp_applicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cp_applications"
    objects: {
      cp: Prisma.$community_partnersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      application_id: string
      cp_id: string
      application_data: Prisma.JsonValue
      status: $Enums.CpApplicationStatus
      reviewed_by: string | null
      reviewed_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["cp_applications"]>
    composites: {}
  }

  type cp_applicationsGetPayload<S extends boolean | null | undefined | cp_applicationsDefaultArgs> = $Result.GetResult<Prisma.$cp_applicationsPayload, S>

  type cp_applicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cp_applicationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cp_applicationsCountAggregateInputType | true
    }

  export interface cp_applicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cp_applications'], meta: { name: 'cp_applications' } }
    /**
     * Find zero or one Cp_applications that matches the filter.
     * @param {cp_applicationsFindUniqueArgs} args - Arguments to find a Cp_applications
     * @example
     * // Get one Cp_applications
     * const cp_applications = await prisma.cp_applications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cp_applicationsFindUniqueArgs>(args: SelectSubset<T, cp_applicationsFindUniqueArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cp_applications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cp_applicationsFindUniqueOrThrowArgs} args - Arguments to find a Cp_applications
     * @example
     * // Get one Cp_applications
     * const cp_applications = await prisma.cp_applications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cp_applicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, cp_applicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cp_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_applicationsFindFirstArgs} args - Arguments to find a Cp_applications
     * @example
     * // Get one Cp_applications
     * const cp_applications = await prisma.cp_applications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cp_applicationsFindFirstArgs>(args?: SelectSubset<T, cp_applicationsFindFirstArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cp_applications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_applicationsFindFirstOrThrowArgs} args - Arguments to find a Cp_applications
     * @example
     * // Get one Cp_applications
     * const cp_applications = await prisma.cp_applications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cp_applicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, cp_applicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cp_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_applicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cp_applications
     * const cp_applications = await prisma.cp_applications.findMany()
     * 
     * // Get first 10 Cp_applications
     * const cp_applications = await prisma.cp_applications.findMany({ take: 10 })
     * 
     * // Only select the `application_id`
     * const cp_applicationsWithApplication_idOnly = await prisma.cp_applications.findMany({ select: { application_id: true } })
     * 
     */
    findMany<T extends cp_applicationsFindManyArgs>(args?: SelectSubset<T, cp_applicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cp_applications.
     * @param {cp_applicationsCreateArgs} args - Arguments to create a Cp_applications.
     * @example
     * // Create one Cp_applications
     * const Cp_applications = await prisma.cp_applications.create({
     *   data: {
     *     // ... data to create a Cp_applications
     *   }
     * })
     * 
     */
    create<T extends cp_applicationsCreateArgs>(args: SelectSubset<T, cp_applicationsCreateArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cp_applications.
     * @param {cp_applicationsCreateManyArgs} args - Arguments to create many Cp_applications.
     * @example
     * // Create many Cp_applications
     * const cp_applications = await prisma.cp_applications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cp_applicationsCreateManyArgs>(args?: SelectSubset<T, cp_applicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cp_applications and returns the data saved in the database.
     * @param {cp_applicationsCreateManyAndReturnArgs} args - Arguments to create many Cp_applications.
     * @example
     * // Create many Cp_applications
     * const cp_applications = await prisma.cp_applications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cp_applications and only return the `application_id`
     * const cp_applicationsWithApplication_idOnly = await prisma.cp_applications.createManyAndReturn({ 
     *   select: { application_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cp_applicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, cp_applicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cp_applications.
     * @param {cp_applicationsDeleteArgs} args - Arguments to delete one Cp_applications.
     * @example
     * // Delete one Cp_applications
     * const Cp_applications = await prisma.cp_applications.delete({
     *   where: {
     *     // ... filter to delete one Cp_applications
     *   }
     * })
     * 
     */
    delete<T extends cp_applicationsDeleteArgs>(args: SelectSubset<T, cp_applicationsDeleteArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cp_applications.
     * @param {cp_applicationsUpdateArgs} args - Arguments to update one Cp_applications.
     * @example
     * // Update one Cp_applications
     * const cp_applications = await prisma.cp_applications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cp_applicationsUpdateArgs>(args: SelectSubset<T, cp_applicationsUpdateArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cp_applications.
     * @param {cp_applicationsDeleteManyArgs} args - Arguments to filter Cp_applications to delete.
     * @example
     * // Delete a few Cp_applications
     * const { count } = await prisma.cp_applications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cp_applicationsDeleteManyArgs>(args?: SelectSubset<T, cp_applicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cp_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_applicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cp_applications
     * const cp_applications = await prisma.cp_applications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cp_applicationsUpdateManyArgs>(args: SelectSubset<T, cp_applicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cp_applications.
     * @param {cp_applicationsUpsertArgs} args - Arguments to update or create a Cp_applications.
     * @example
     * // Update or create a Cp_applications
     * const cp_applications = await prisma.cp_applications.upsert({
     *   create: {
     *     // ... data to create a Cp_applications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cp_applications we want to update
     *   }
     * })
     */
    upsert<T extends cp_applicationsUpsertArgs>(args: SelectSubset<T, cp_applicationsUpsertArgs<ExtArgs>>): Prisma__cp_applicationsClient<$Result.GetResult<Prisma.$cp_applicationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cp_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_applicationsCountArgs} args - Arguments to filter Cp_applications to count.
     * @example
     * // Count the number of Cp_applications
     * const count = await prisma.cp_applications.count({
     *   where: {
     *     // ... the filter for the Cp_applications we want to count
     *   }
     * })
    **/
    count<T extends cp_applicationsCountArgs>(
      args?: Subset<T, cp_applicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cp_applicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cp_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cp_applicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cp_applicationsAggregateArgs>(args: Subset<T, Cp_applicationsAggregateArgs>): Prisma.PrismaPromise<GetCp_applicationsAggregateType<T>>

    /**
     * Group by Cp_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_applicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cp_applicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cp_applicationsGroupByArgs['orderBy'] }
        : { orderBy?: cp_applicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cp_applicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCp_applicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cp_applications model
   */
  readonly fields: cp_applicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cp_applications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cp_applicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cp<T extends community_partnersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, community_partnersDefaultArgs<ExtArgs>>): Prisma__community_partnersClient<$Result.GetResult<Prisma.$community_partnersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cp_applications model
   */ 
  interface cp_applicationsFieldRefs {
    readonly application_id: FieldRef<"cp_applications", 'String'>
    readonly cp_id: FieldRef<"cp_applications", 'String'>
    readonly application_data: FieldRef<"cp_applications", 'Json'>
    readonly status: FieldRef<"cp_applications", 'CpApplicationStatus'>
    readonly reviewed_by: FieldRef<"cp_applications", 'String'>
    readonly reviewed_at: FieldRef<"cp_applications", 'DateTime'>
    readonly created_at: FieldRef<"cp_applications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cp_applications findUnique
   */
  export type cp_applicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which cp_applications to fetch.
     */
    where: cp_applicationsWhereUniqueInput
  }

  /**
   * cp_applications findUniqueOrThrow
   */
  export type cp_applicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which cp_applications to fetch.
     */
    where: cp_applicationsWhereUniqueInput
  }

  /**
   * cp_applications findFirst
   */
  export type cp_applicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which cp_applications to fetch.
     */
    where?: cp_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_applications to fetch.
     */
    orderBy?: cp_applicationsOrderByWithRelationInput | cp_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cp_applications.
     */
    cursor?: cp_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cp_applications.
     */
    distinct?: Cp_applicationsScalarFieldEnum | Cp_applicationsScalarFieldEnum[]
  }

  /**
   * cp_applications findFirstOrThrow
   */
  export type cp_applicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which cp_applications to fetch.
     */
    where?: cp_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_applications to fetch.
     */
    orderBy?: cp_applicationsOrderByWithRelationInput | cp_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cp_applications.
     */
    cursor?: cp_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cp_applications.
     */
    distinct?: Cp_applicationsScalarFieldEnum | Cp_applicationsScalarFieldEnum[]
  }

  /**
   * cp_applications findMany
   */
  export type cp_applicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which cp_applications to fetch.
     */
    where?: cp_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_applications to fetch.
     */
    orderBy?: cp_applicationsOrderByWithRelationInput | cp_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cp_applications.
     */
    cursor?: cp_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_applications.
     */
    skip?: number
    distinct?: Cp_applicationsScalarFieldEnum | Cp_applicationsScalarFieldEnum[]
  }

  /**
   * cp_applications create
   */
  export type cp_applicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a cp_applications.
     */
    data: XOR<cp_applicationsCreateInput, cp_applicationsUncheckedCreateInput>
  }

  /**
   * cp_applications createMany
   */
  export type cp_applicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cp_applications.
     */
    data: cp_applicationsCreateManyInput | cp_applicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cp_applications createManyAndReturn
   */
  export type cp_applicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many cp_applications.
     */
    data: cp_applicationsCreateManyInput | cp_applicationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cp_applications update
   */
  export type cp_applicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a cp_applications.
     */
    data: XOR<cp_applicationsUpdateInput, cp_applicationsUncheckedUpdateInput>
    /**
     * Choose, which cp_applications to update.
     */
    where: cp_applicationsWhereUniqueInput
  }

  /**
   * cp_applications updateMany
   */
  export type cp_applicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cp_applications.
     */
    data: XOR<cp_applicationsUpdateManyMutationInput, cp_applicationsUncheckedUpdateManyInput>
    /**
     * Filter which cp_applications to update
     */
    where?: cp_applicationsWhereInput
  }

  /**
   * cp_applications upsert
   */
  export type cp_applicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the cp_applications to update in case it exists.
     */
    where: cp_applicationsWhereUniqueInput
    /**
     * In case the cp_applications found by the `where` argument doesn't exist, create a new cp_applications with this data.
     */
    create: XOR<cp_applicationsCreateInput, cp_applicationsUncheckedCreateInput>
    /**
     * In case the cp_applications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cp_applicationsUpdateInput, cp_applicationsUncheckedUpdateInput>
  }

  /**
   * cp_applications delete
   */
  export type cp_applicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
    /**
     * Filter which cp_applications to delete.
     */
    where: cp_applicationsWhereUniqueInput
  }

  /**
   * cp_applications deleteMany
   */
  export type cp_applicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cp_applications to delete
     */
    where?: cp_applicationsWhereInput
  }

  /**
   * cp_applications without action
   */
  export type cp_applicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_applications
     */
    select?: cp_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cp_applicationsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: string | null
    email: string | null
    password: string | null
    role: string | null
    cp_id: string | null
    created_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: string | null
    email: string | null
    password: string | null
    role: string | null
    cp_id: string | null
    created_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    email: number
    password: number
    role: number
    cp_id: number
    created_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    role?: true
    cp_id?: true
    created_at?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    role?: true
    cp_id?: true
    created_at?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    role?: true
    cp_id?: true
    created_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: string
    email: string
    password: string
    role: string
    cp_id: string | null
    created_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    cp_id?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    cp_id?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    user_id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    cp_id?: boolean
    created_at?: boolean
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      email: string
      password: string
      role: string
      cp_id: string | null
      created_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly cp_id: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
  }


  /**
   * Model cp_leads
   */

  export type AggregateCp_leads = {
    _count: Cp_leadsCountAggregateOutputType | null
    _min: Cp_leadsMinAggregateOutputType | null
    _max: Cp_leadsMaxAggregateOutputType | null
  }

  export type Cp_leadsMinAggregateOutputType = {
    lead_id: string | null
    cp_id: string | null
    church_name: string | null
    location: string | null
    stage: string | null
    notes: string | null
    last_updated: Date | null
  }

  export type Cp_leadsMaxAggregateOutputType = {
    lead_id: string | null
    cp_id: string | null
    church_name: string | null
    location: string | null
    stage: string | null
    notes: string | null
    last_updated: Date | null
  }

  export type Cp_leadsCountAggregateOutputType = {
    lead_id: number
    cp_id: number
    church_name: number
    location: number
    stage: number
    notes: number
    last_updated: number
    _all: number
  }


  export type Cp_leadsMinAggregateInputType = {
    lead_id?: true
    cp_id?: true
    church_name?: true
    location?: true
    stage?: true
    notes?: true
    last_updated?: true
  }

  export type Cp_leadsMaxAggregateInputType = {
    lead_id?: true
    cp_id?: true
    church_name?: true
    location?: true
    stage?: true
    notes?: true
    last_updated?: true
  }

  export type Cp_leadsCountAggregateInputType = {
    lead_id?: true
    cp_id?: true
    church_name?: true
    location?: true
    stage?: true
    notes?: true
    last_updated?: true
    _all?: true
  }

  export type Cp_leadsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cp_leads to aggregate.
     */
    where?: cp_leadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_leads to fetch.
     */
    orderBy?: cp_leadsOrderByWithRelationInput | cp_leadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cp_leadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cp_leads
    **/
    _count?: true | Cp_leadsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cp_leadsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cp_leadsMaxAggregateInputType
  }

  export type GetCp_leadsAggregateType<T extends Cp_leadsAggregateArgs> = {
        [P in keyof T & keyof AggregateCp_leads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCp_leads[P]>
      : GetScalarType<T[P], AggregateCp_leads[P]>
  }




  export type cp_leadsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cp_leadsWhereInput
    orderBy?: cp_leadsOrderByWithAggregationInput | cp_leadsOrderByWithAggregationInput[]
    by: Cp_leadsScalarFieldEnum[] | Cp_leadsScalarFieldEnum
    having?: cp_leadsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cp_leadsCountAggregateInputType | true
    _min?: Cp_leadsMinAggregateInputType
    _max?: Cp_leadsMaxAggregateInputType
  }

  export type Cp_leadsGroupByOutputType = {
    lead_id: string
    cp_id: string
    church_name: string
    location: string
    stage: string
    notes: string | null
    last_updated: Date
    _count: Cp_leadsCountAggregateOutputType | null
    _min: Cp_leadsMinAggregateOutputType | null
    _max: Cp_leadsMaxAggregateOutputType | null
  }

  type GetCp_leadsGroupByPayload<T extends cp_leadsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cp_leadsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cp_leadsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cp_leadsGroupByOutputType[P]>
            : GetScalarType<T[P], Cp_leadsGroupByOutputType[P]>
        }
      >
    >


  export type cp_leadsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lead_id?: boolean
    cp_id?: boolean
    church_name?: boolean
    location?: boolean
    stage?: boolean
    notes?: boolean
    last_updated?: boolean
  }, ExtArgs["result"]["cp_leads"]>

  export type cp_leadsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lead_id?: boolean
    cp_id?: boolean
    church_name?: boolean
    location?: boolean
    stage?: boolean
    notes?: boolean
    last_updated?: boolean
  }, ExtArgs["result"]["cp_leads"]>

  export type cp_leadsSelectScalar = {
    lead_id?: boolean
    cp_id?: boolean
    church_name?: boolean
    location?: boolean
    stage?: boolean
    notes?: boolean
    last_updated?: boolean
  }


  export type $cp_leadsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cp_leads"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      lead_id: string
      cp_id: string
      church_name: string
      location: string
      stage: string
      notes: string | null
      last_updated: Date
    }, ExtArgs["result"]["cp_leads"]>
    composites: {}
  }

  type cp_leadsGetPayload<S extends boolean | null | undefined | cp_leadsDefaultArgs> = $Result.GetResult<Prisma.$cp_leadsPayload, S>

  type cp_leadsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cp_leadsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cp_leadsCountAggregateInputType | true
    }

  export interface cp_leadsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cp_leads'], meta: { name: 'cp_leads' } }
    /**
     * Find zero or one Cp_leads that matches the filter.
     * @param {cp_leadsFindUniqueArgs} args - Arguments to find a Cp_leads
     * @example
     * // Get one Cp_leads
     * const cp_leads = await prisma.cp_leads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cp_leadsFindUniqueArgs>(args: SelectSubset<T, cp_leadsFindUniqueArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cp_leads that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cp_leadsFindUniqueOrThrowArgs} args - Arguments to find a Cp_leads
     * @example
     * // Get one Cp_leads
     * const cp_leads = await prisma.cp_leads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cp_leadsFindUniqueOrThrowArgs>(args: SelectSubset<T, cp_leadsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cp_leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_leadsFindFirstArgs} args - Arguments to find a Cp_leads
     * @example
     * // Get one Cp_leads
     * const cp_leads = await prisma.cp_leads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cp_leadsFindFirstArgs>(args?: SelectSubset<T, cp_leadsFindFirstArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cp_leads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_leadsFindFirstOrThrowArgs} args - Arguments to find a Cp_leads
     * @example
     * // Get one Cp_leads
     * const cp_leads = await prisma.cp_leads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cp_leadsFindFirstOrThrowArgs>(args?: SelectSubset<T, cp_leadsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cp_leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_leadsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cp_leads
     * const cp_leads = await prisma.cp_leads.findMany()
     * 
     * // Get first 10 Cp_leads
     * const cp_leads = await prisma.cp_leads.findMany({ take: 10 })
     * 
     * // Only select the `lead_id`
     * const cp_leadsWithLead_idOnly = await prisma.cp_leads.findMany({ select: { lead_id: true } })
     * 
     */
    findMany<T extends cp_leadsFindManyArgs>(args?: SelectSubset<T, cp_leadsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cp_leads.
     * @param {cp_leadsCreateArgs} args - Arguments to create a Cp_leads.
     * @example
     * // Create one Cp_leads
     * const Cp_leads = await prisma.cp_leads.create({
     *   data: {
     *     // ... data to create a Cp_leads
     *   }
     * })
     * 
     */
    create<T extends cp_leadsCreateArgs>(args: SelectSubset<T, cp_leadsCreateArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cp_leads.
     * @param {cp_leadsCreateManyArgs} args - Arguments to create many Cp_leads.
     * @example
     * // Create many Cp_leads
     * const cp_leads = await prisma.cp_leads.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cp_leadsCreateManyArgs>(args?: SelectSubset<T, cp_leadsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cp_leads and returns the data saved in the database.
     * @param {cp_leadsCreateManyAndReturnArgs} args - Arguments to create many Cp_leads.
     * @example
     * // Create many Cp_leads
     * const cp_leads = await prisma.cp_leads.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cp_leads and only return the `lead_id`
     * const cp_leadsWithLead_idOnly = await prisma.cp_leads.createManyAndReturn({ 
     *   select: { lead_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cp_leadsCreateManyAndReturnArgs>(args?: SelectSubset<T, cp_leadsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cp_leads.
     * @param {cp_leadsDeleteArgs} args - Arguments to delete one Cp_leads.
     * @example
     * // Delete one Cp_leads
     * const Cp_leads = await prisma.cp_leads.delete({
     *   where: {
     *     // ... filter to delete one Cp_leads
     *   }
     * })
     * 
     */
    delete<T extends cp_leadsDeleteArgs>(args: SelectSubset<T, cp_leadsDeleteArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cp_leads.
     * @param {cp_leadsUpdateArgs} args - Arguments to update one Cp_leads.
     * @example
     * // Update one Cp_leads
     * const cp_leads = await prisma.cp_leads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cp_leadsUpdateArgs>(args: SelectSubset<T, cp_leadsUpdateArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cp_leads.
     * @param {cp_leadsDeleteManyArgs} args - Arguments to filter Cp_leads to delete.
     * @example
     * // Delete a few Cp_leads
     * const { count } = await prisma.cp_leads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cp_leadsDeleteManyArgs>(args?: SelectSubset<T, cp_leadsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cp_leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_leadsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cp_leads
     * const cp_leads = await prisma.cp_leads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cp_leadsUpdateManyArgs>(args: SelectSubset<T, cp_leadsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cp_leads.
     * @param {cp_leadsUpsertArgs} args - Arguments to update or create a Cp_leads.
     * @example
     * // Update or create a Cp_leads
     * const cp_leads = await prisma.cp_leads.upsert({
     *   create: {
     *     // ... data to create a Cp_leads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cp_leads we want to update
     *   }
     * })
     */
    upsert<T extends cp_leadsUpsertArgs>(args: SelectSubset<T, cp_leadsUpsertArgs<ExtArgs>>): Prisma__cp_leadsClient<$Result.GetResult<Prisma.$cp_leadsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cp_leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_leadsCountArgs} args - Arguments to filter Cp_leads to count.
     * @example
     * // Count the number of Cp_leads
     * const count = await prisma.cp_leads.count({
     *   where: {
     *     // ... the filter for the Cp_leads we want to count
     *   }
     * })
    **/
    count<T extends cp_leadsCountArgs>(
      args?: Subset<T, cp_leadsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cp_leadsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cp_leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cp_leadsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cp_leadsAggregateArgs>(args: Subset<T, Cp_leadsAggregateArgs>): Prisma.PrismaPromise<GetCp_leadsAggregateType<T>>

    /**
     * Group by Cp_leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cp_leadsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cp_leadsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cp_leadsGroupByArgs['orderBy'] }
        : { orderBy?: cp_leadsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cp_leadsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCp_leadsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cp_leads model
   */
  readonly fields: cp_leadsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cp_leads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cp_leadsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cp_leads model
   */ 
  interface cp_leadsFieldRefs {
    readonly lead_id: FieldRef<"cp_leads", 'String'>
    readonly cp_id: FieldRef<"cp_leads", 'String'>
    readonly church_name: FieldRef<"cp_leads", 'String'>
    readonly location: FieldRef<"cp_leads", 'String'>
    readonly stage: FieldRef<"cp_leads", 'String'>
    readonly notes: FieldRef<"cp_leads", 'String'>
    readonly last_updated: FieldRef<"cp_leads", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cp_leads findUnique
   */
  export type cp_leadsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * Filter, which cp_leads to fetch.
     */
    where: cp_leadsWhereUniqueInput
  }

  /**
   * cp_leads findUniqueOrThrow
   */
  export type cp_leadsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * Filter, which cp_leads to fetch.
     */
    where: cp_leadsWhereUniqueInput
  }

  /**
   * cp_leads findFirst
   */
  export type cp_leadsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * Filter, which cp_leads to fetch.
     */
    where?: cp_leadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_leads to fetch.
     */
    orderBy?: cp_leadsOrderByWithRelationInput | cp_leadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cp_leads.
     */
    cursor?: cp_leadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cp_leads.
     */
    distinct?: Cp_leadsScalarFieldEnum | Cp_leadsScalarFieldEnum[]
  }

  /**
   * cp_leads findFirstOrThrow
   */
  export type cp_leadsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * Filter, which cp_leads to fetch.
     */
    where?: cp_leadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_leads to fetch.
     */
    orderBy?: cp_leadsOrderByWithRelationInput | cp_leadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cp_leads.
     */
    cursor?: cp_leadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cp_leads.
     */
    distinct?: Cp_leadsScalarFieldEnum | Cp_leadsScalarFieldEnum[]
  }

  /**
   * cp_leads findMany
   */
  export type cp_leadsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * Filter, which cp_leads to fetch.
     */
    where?: cp_leadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cp_leads to fetch.
     */
    orderBy?: cp_leadsOrderByWithRelationInput | cp_leadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cp_leads.
     */
    cursor?: cp_leadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cp_leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cp_leads.
     */
    skip?: number
    distinct?: Cp_leadsScalarFieldEnum | Cp_leadsScalarFieldEnum[]
  }

  /**
   * cp_leads create
   */
  export type cp_leadsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * The data needed to create a cp_leads.
     */
    data: XOR<cp_leadsCreateInput, cp_leadsUncheckedCreateInput>
  }

  /**
   * cp_leads createMany
   */
  export type cp_leadsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cp_leads.
     */
    data: cp_leadsCreateManyInput | cp_leadsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cp_leads createManyAndReturn
   */
  export type cp_leadsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many cp_leads.
     */
    data: cp_leadsCreateManyInput | cp_leadsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cp_leads update
   */
  export type cp_leadsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * The data needed to update a cp_leads.
     */
    data: XOR<cp_leadsUpdateInput, cp_leadsUncheckedUpdateInput>
    /**
     * Choose, which cp_leads to update.
     */
    where: cp_leadsWhereUniqueInput
  }

  /**
   * cp_leads updateMany
   */
  export type cp_leadsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cp_leads.
     */
    data: XOR<cp_leadsUpdateManyMutationInput, cp_leadsUncheckedUpdateManyInput>
    /**
     * Filter which cp_leads to update
     */
    where?: cp_leadsWhereInput
  }

  /**
   * cp_leads upsert
   */
  export type cp_leadsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * The filter to search for the cp_leads to update in case it exists.
     */
    where: cp_leadsWhereUniqueInput
    /**
     * In case the cp_leads found by the `where` argument doesn't exist, create a new cp_leads with this data.
     */
    create: XOR<cp_leadsCreateInput, cp_leadsUncheckedCreateInput>
    /**
     * In case the cp_leads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cp_leadsUpdateInput, cp_leadsUncheckedUpdateInput>
  }

  /**
   * cp_leads delete
   */
  export type cp_leadsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
    /**
     * Filter which cp_leads to delete.
     */
    where: cp_leadsWhereUniqueInput
  }

  /**
   * cp_leads deleteMany
   */
  export type cp_leadsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cp_leads to delete
     */
    where?: cp_leadsWhereInput
  }

  /**
   * cp_leads without action
   */
  export type cp_leadsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cp_leads
     */
    select?: cp_leadsSelect<ExtArgs> | null
  }


  /**
   * Model incentives
   */

  export type AggregateIncentives = {
    _count: IncentivesCountAggregateOutputType | null
    _avg: IncentivesAvgAggregateOutputType | null
    _sum: IncentivesSumAggregateOutputType | null
    _min: IncentivesMinAggregateOutputType | null
    _max: IncentivesMaxAggregateOutputType | null
  }

  export type IncentivesAvgAggregateOutputType = {
    amount: number | null
  }

  export type IncentivesSumAggregateOutputType = {
    amount: number | null
  }

  export type IncentivesMinAggregateOutputType = {
    incentive_id: string | null
    cp_id: string | null
    lead_id: string | null
    amount: number | null
    status: string | null
  }

  export type IncentivesMaxAggregateOutputType = {
    incentive_id: string | null
    cp_id: string | null
    lead_id: string | null
    amount: number | null
    status: string | null
  }

  export type IncentivesCountAggregateOutputType = {
    incentive_id: number
    cp_id: number
    lead_id: number
    amount: number
    status: number
    _all: number
  }


  export type IncentivesAvgAggregateInputType = {
    amount?: true
  }

  export type IncentivesSumAggregateInputType = {
    amount?: true
  }

  export type IncentivesMinAggregateInputType = {
    incentive_id?: true
    cp_id?: true
    lead_id?: true
    amount?: true
    status?: true
  }

  export type IncentivesMaxAggregateInputType = {
    incentive_id?: true
    cp_id?: true
    lead_id?: true
    amount?: true
    status?: true
  }

  export type IncentivesCountAggregateInputType = {
    incentive_id?: true
    cp_id?: true
    lead_id?: true
    amount?: true
    status?: true
    _all?: true
  }

  export type IncentivesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which incentives to aggregate.
     */
    where?: incentivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentives to fetch.
     */
    orderBy?: incentivesOrderByWithRelationInput | incentivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: incentivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned incentives
    **/
    _count?: true | IncentivesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncentivesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncentivesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncentivesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncentivesMaxAggregateInputType
  }

  export type GetIncentivesAggregateType<T extends IncentivesAggregateArgs> = {
        [P in keyof T & keyof AggregateIncentives]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncentives[P]>
      : GetScalarType<T[P], AggregateIncentives[P]>
  }




  export type incentivesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: incentivesWhereInput
    orderBy?: incentivesOrderByWithAggregationInput | incentivesOrderByWithAggregationInput[]
    by: IncentivesScalarFieldEnum[] | IncentivesScalarFieldEnum
    having?: incentivesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncentivesCountAggregateInputType | true
    _avg?: IncentivesAvgAggregateInputType
    _sum?: IncentivesSumAggregateInputType
    _min?: IncentivesMinAggregateInputType
    _max?: IncentivesMaxAggregateInputType
  }

  export type IncentivesGroupByOutputType = {
    incentive_id: string
    cp_id: string
    lead_id: string
    amount: number
    status: string
    _count: IncentivesCountAggregateOutputType | null
    _avg: IncentivesAvgAggregateOutputType | null
    _sum: IncentivesSumAggregateOutputType | null
    _min: IncentivesMinAggregateOutputType | null
    _max: IncentivesMaxAggregateOutputType | null
  }

  type GetIncentivesGroupByPayload<T extends incentivesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncentivesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncentivesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncentivesGroupByOutputType[P]>
            : GetScalarType<T[P], IncentivesGroupByOutputType[P]>
        }
      >
    >


  export type incentivesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    incentive_id?: boolean
    cp_id?: boolean
    lead_id?: boolean
    amount?: boolean
    status?: boolean
  }, ExtArgs["result"]["incentives"]>

  export type incentivesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    incentive_id?: boolean
    cp_id?: boolean
    lead_id?: boolean
    amount?: boolean
    status?: boolean
  }, ExtArgs["result"]["incentives"]>

  export type incentivesSelectScalar = {
    incentive_id?: boolean
    cp_id?: boolean
    lead_id?: boolean
    amount?: boolean
    status?: boolean
  }


  export type $incentivesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "incentives"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      incentive_id: string
      cp_id: string
      lead_id: string
      amount: number
      status: string
    }, ExtArgs["result"]["incentives"]>
    composites: {}
  }

  type incentivesGetPayload<S extends boolean | null | undefined | incentivesDefaultArgs> = $Result.GetResult<Prisma.$incentivesPayload, S>

  type incentivesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<incentivesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncentivesCountAggregateInputType | true
    }

  export interface incentivesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['incentives'], meta: { name: 'incentives' } }
    /**
     * Find zero or one Incentives that matches the filter.
     * @param {incentivesFindUniqueArgs} args - Arguments to find a Incentives
     * @example
     * // Get one Incentives
     * const incentives = await prisma.incentives.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends incentivesFindUniqueArgs>(args: SelectSubset<T, incentivesFindUniqueArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incentives that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {incentivesFindUniqueOrThrowArgs} args - Arguments to find a Incentives
     * @example
     * // Get one Incentives
     * const incentives = await prisma.incentives.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends incentivesFindUniqueOrThrowArgs>(args: SelectSubset<T, incentivesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incentives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentivesFindFirstArgs} args - Arguments to find a Incentives
     * @example
     * // Get one Incentives
     * const incentives = await prisma.incentives.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends incentivesFindFirstArgs>(args?: SelectSubset<T, incentivesFindFirstArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incentives that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentivesFindFirstOrThrowArgs} args - Arguments to find a Incentives
     * @example
     * // Get one Incentives
     * const incentives = await prisma.incentives.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends incentivesFindFirstOrThrowArgs>(args?: SelectSubset<T, incentivesFindFirstOrThrowArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incentives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentivesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incentives
     * const incentives = await prisma.incentives.findMany()
     * 
     * // Get first 10 Incentives
     * const incentives = await prisma.incentives.findMany({ take: 10 })
     * 
     * // Only select the `incentive_id`
     * const incentivesWithIncentive_idOnly = await prisma.incentives.findMany({ select: { incentive_id: true } })
     * 
     */
    findMany<T extends incentivesFindManyArgs>(args?: SelectSubset<T, incentivesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incentives.
     * @param {incentivesCreateArgs} args - Arguments to create a Incentives.
     * @example
     * // Create one Incentives
     * const Incentives = await prisma.incentives.create({
     *   data: {
     *     // ... data to create a Incentives
     *   }
     * })
     * 
     */
    create<T extends incentivesCreateArgs>(args: SelectSubset<T, incentivesCreateArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incentives.
     * @param {incentivesCreateManyArgs} args - Arguments to create many Incentives.
     * @example
     * // Create many Incentives
     * const incentives = await prisma.incentives.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends incentivesCreateManyArgs>(args?: SelectSubset<T, incentivesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incentives and returns the data saved in the database.
     * @param {incentivesCreateManyAndReturnArgs} args - Arguments to create many Incentives.
     * @example
     * // Create many Incentives
     * const incentives = await prisma.incentives.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incentives and only return the `incentive_id`
     * const incentivesWithIncentive_idOnly = await prisma.incentives.createManyAndReturn({ 
     *   select: { incentive_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends incentivesCreateManyAndReturnArgs>(args?: SelectSubset<T, incentivesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incentives.
     * @param {incentivesDeleteArgs} args - Arguments to delete one Incentives.
     * @example
     * // Delete one Incentives
     * const Incentives = await prisma.incentives.delete({
     *   where: {
     *     // ... filter to delete one Incentives
     *   }
     * })
     * 
     */
    delete<T extends incentivesDeleteArgs>(args: SelectSubset<T, incentivesDeleteArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incentives.
     * @param {incentivesUpdateArgs} args - Arguments to update one Incentives.
     * @example
     * // Update one Incentives
     * const incentives = await prisma.incentives.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends incentivesUpdateArgs>(args: SelectSubset<T, incentivesUpdateArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incentives.
     * @param {incentivesDeleteManyArgs} args - Arguments to filter Incentives to delete.
     * @example
     * // Delete a few Incentives
     * const { count } = await prisma.incentives.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends incentivesDeleteManyArgs>(args?: SelectSubset<T, incentivesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentivesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incentives
     * const incentives = await prisma.incentives.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends incentivesUpdateManyArgs>(args: SelectSubset<T, incentivesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incentives.
     * @param {incentivesUpsertArgs} args - Arguments to update or create a Incentives.
     * @example
     * // Update or create a Incentives
     * const incentives = await prisma.incentives.upsert({
     *   create: {
     *     // ... data to create a Incentives
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incentives we want to update
     *   }
     * })
     */
    upsert<T extends incentivesUpsertArgs>(args: SelectSubset<T, incentivesUpsertArgs<ExtArgs>>): Prisma__incentivesClient<$Result.GetResult<Prisma.$incentivesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentivesCountArgs} args - Arguments to filter Incentives to count.
     * @example
     * // Count the number of Incentives
     * const count = await prisma.incentives.count({
     *   where: {
     *     // ... the filter for the Incentives we want to count
     *   }
     * })
    **/
    count<T extends incentivesCountArgs>(
      args?: Subset<T, incentivesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncentivesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentivesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncentivesAggregateArgs>(args: Subset<T, IncentivesAggregateArgs>): Prisma.PrismaPromise<GetIncentivesAggregateType<T>>

    /**
     * Group by Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentivesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends incentivesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: incentivesGroupByArgs['orderBy'] }
        : { orderBy?: incentivesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, incentivesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncentivesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the incentives model
   */
  readonly fields: incentivesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for incentives.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__incentivesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the incentives model
   */ 
  interface incentivesFieldRefs {
    readonly incentive_id: FieldRef<"incentives", 'String'>
    readonly cp_id: FieldRef<"incentives", 'String'>
    readonly lead_id: FieldRef<"incentives", 'String'>
    readonly amount: FieldRef<"incentives", 'Int'>
    readonly status: FieldRef<"incentives", 'String'>
  }
    

  // Custom InputTypes
  /**
   * incentives findUnique
   */
  export type incentivesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * Filter, which incentives to fetch.
     */
    where: incentivesWhereUniqueInput
  }

  /**
   * incentives findUniqueOrThrow
   */
  export type incentivesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * Filter, which incentives to fetch.
     */
    where: incentivesWhereUniqueInput
  }

  /**
   * incentives findFirst
   */
  export type incentivesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * Filter, which incentives to fetch.
     */
    where?: incentivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentives to fetch.
     */
    orderBy?: incentivesOrderByWithRelationInput | incentivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incentives.
     */
    cursor?: incentivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incentives.
     */
    distinct?: IncentivesScalarFieldEnum | IncentivesScalarFieldEnum[]
  }

  /**
   * incentives findFirstOrThrow
   */
  export type incentivesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * Filter, which incentives to fetch.
     */
    where?: incentivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentives to fetch.
     */
    orderBy?: incentivesOrderByWithRelationInput | incentivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incentives.
     */
    cursor?: incentivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incentives.
     */
    distinct?: IncentivesScalarFieldEnum | IncentivesScalarFieldEnum[]
  }

  /**
   * incentives findMany
   */
  export type incentivesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * Filter, which incentives to fetch.
     */
    where?: incentivesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentives to fetch.
     */
    orderBy?: incentivesOrderByWithRelationInput | incentivesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing incentives.
     */
    cursor?: incentivesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentives.
     */
    skip?: number
    distinct?: IncentivesScalarFieldEnum | IncentivesScalarFieldEnum[]
  }

  /**
   * incentives create
   */
  export type incentivesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * The data needed to create a incentives.
     */
    data: XOR<incentivesCreateInput, incentivesUncheckedCreateInput>
  }

  /**
   * incentives createMany
   */
  export type incentivesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many incentives.
     */
    data: incentivesCreateManyInput | incentivesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * incentives createManyAndReturn
   */
  export type incentivesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many incentives.
     */
    data: incentivesCreateManyInput | incentivesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * incentives update
   */
  export type incentivesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * The data needed to update a incentives.
     */
    data: XOR<incentivesUpdateInput, incentivesUncheckedUpdateInput>
    /**
     * Choose, which incentives to update.
     */
    where: incentivesWhereUniqueInput
  }

  /**
   * incentives updateMany
   */
  export type incentivesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update incentives.
     */
    data: XOR<incentivesUpdateManyMutationInput, incentivesUncheckedUpdateManyInput>
    /**
     * Filter which incentives to update
     */
    where?: incentivesWhereInput
  }

  /**
   * incentives upsert
   */
  export type incentivesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * The filter to search for the incentives to update in case it exists.
     */
    where: incentivesWhereUniqueInput
    /**
     * In case the incentives found by the `where` argument doesn't exist, create a new incentives with this data.
     */
    create: XOR<incentivesCreateInput, incentivesUncheckedCreateInput>
    /**
     * In case the incentives was found with the provided `where` argument, update it with this data.
     */
    update: XOR<incentivesUpdateInput, incentivesUncheckedUpdateInput>
  }

  /**
   * incentives delete
   */
  export type incentivesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
    /**
     * Filter which incentives to delete.
     */
    where: incentivesWhereUniqueInput
  }

  /**
   * incentives deleteMany
   */
  export type incentivesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which incentives to delete
     */
    where?: incentivesWhereInput
  }

  /**
   * incentives without action
   */
  export type incentivesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentives
     */
    select?: incentivesSelect<ExtArgs> | null
  }


  /**
   * Model incentive_config
   */

  export type AggregateIncentive_config = {
    _count: Incentive_configCountAggregateOutputType | null
    _avg: Incentive_configAvgAggregateOutputType | null
    _sum: Incentive_configSumAggregateOutputType | null
    _min: Incentive_configMinAggregateOutputType | null
    _max: Incentive_configMaxAggregateOutputType | null
  }

  export type Incentive_configAvgAggregateOutputType = {
    value: number | null
  }

  export type Incentive_configSumAggregateOutputType = {
    value: number | null
  }

  export type Incentive_configMinAggregateOutputType = {
    key: string | null
    value: number | null
  }

  export type Incentive_configMaxAggregateOutputType = {
    key: string | null
    value: number | null
  }

  export type Incentive_configCountAggregateOutputType = {
    key: number
    value: number
    _all: number
  }


  export type Incentive_configAvgAggregateInputType = {
    value?: true
  }

  export type Incentive_configSumAggregateInputType = {
    value?: true
  }

  export type Incentive_configMinAggregateInputType = {
    key?: true
    value?: true
  }

  export type Incentive_configMaxAggregateInputType = {
    key?: true
    value?: true
  }

  export type Incentive_configCountAggregateInputType = {
    key?: true
    value?: true
    _all?: true
  }

  export type Incentive_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which incentive_config to aggregate.
     */
    where?: incentive_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentive_configs to fetch.
     */
    orderBy?: incentive_configOrderByWithRelationInput | incentive_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: incentive_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentive_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentive_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned incentive_configs
    **/
    _count?: true | Incentive_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Incentive_configAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Incentive_configSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Incentive_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Incentive_configMaxAggregateInputType
  }

  export type GetIncentive_configAggregateType<T extends Incentive_configAggregateArgs> = {
        [P in keyof T & keyof AggregateIncentive_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncentive_config[P]>
      : GetScalarType<T[P], AggregateIncentive_config[P]>
  }




  export type incentive_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: incentive_configWhereInput
    orderBy?: incentive_configOrderByWithAggregationInput | incentive_configOrderByWithAggregationInput[]
    by: Incentive_configScalarFieldEnum[] | Incentive_configScalarFieldEnum
    having?: incentive_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Incentive_configCountAggregateInputType | true
    _avg?: Incentive_configAvgAggregateInputType
    _sum?: Incentive_configSumAggregateInputType
    _min?: Incentive_configMinAggregateInputType
    _max?: Incentive_configMaxAggregateInputType
  }

  export type Incentive_configGroupByOutputType = {
    key: string
    value: number
    _count: Incentive_configCountAggregateOutputType | null
    _avg: Incentive_configAvgAggregateOutputType | null
    _sum: Incentive_configSumAggregateOutputType | null
    _min: Incentive_configMinAggregateOutputType | null
    _max: Incentive_configMaxAggregateOutputType | null
  }

  type GetIncentive_configGroupByPayload<T extends incentive_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Incentive_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Incentive_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Incentive_configGroupByOutputType[P]>
            : GetScalarType<T[P], Incentive_configGroupByOutputType[P]>
        }
      >
    >


  export type incentive_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["incentive_config"]>

  export type incentive_configSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["incentive_config"]>

  export type incentive_configSelectScalar = {
    key?: boolean
    value?: boolean
  }


  export type $incentive_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "incentive_config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: number
    }, ExtArgs["result"]["incentive_config"]>
    composites: {}
  }

  type incentive_configGetPayload<S extends boolean | null | undefined | incentive_configDefaultArgs> = $Result.GetResult<Prisma.$incentive_configPayload, S>

  type incentive_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<incentive_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Incentive_configCountAggregateInputType | true
    }

  export interface incentive_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['incentive_config'], meta: { name: 'incentive_config' } }
    /**
     * Find zero or one Incentive_config that matches the filter.
     * @param {incentive_configFindUniqueArgs} args - Arguments to find a Incentive_config
     * @example
     * // Get one Incentive_config
     * const incentive_config = await prisma.incentive_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends incentive_configFindUniqueArgs>(args: SelectSubset<T, incentive_configFindUniqueArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incentive_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {incentive_configFindUniqueOrThrowArgs} args - Arguments to find a Incentive_config
     * @example
     * // Get one Incentive_config
     * const incentive_config = await prisma.incentive_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends incentive_configFindUniqueOrThrowArgs>(args: SelectSubset<T, incentive_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incentive_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentive_configFindFirstArgs} args - Arguments to find a Incentive_config
     * @example
     * // Get one Incentive_config
     * const incentive_config = await prisma.incentive_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends incentive_configFindFirstArgs>(args?: SelectSubset<T, incentive_configFindFirstArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incentive_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentive_configFindFirstOrThrowArgs} args - Arguments to find a Incentive_config
     * @example
     * // Get one Incentive_config
     * const incentive_config = await prisma.incentive_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends incentive_configFindFirstOrThrowArgs>(args?: SelectSubset<T, incentive_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incentive_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentive_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incentive_configs
     * const incentive_configs = await prisma.incentive_config.findMany()
     * 
     * // Get first 10 Incentive_configs
     * const incentive_configs = await prisma.incentive_config.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const incentive_configWithKeyOnly = await prisma.incentive_config.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends incentive_configFindManyArgs>(args?: SelectSubset<T, incentive_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incentive_config.
     * @param {incentive_configCreateArgs} args - Arguments to create a Incentive_config.
     * @example
     * // Create one Incentive_config
     * const Incentive_config = await prisma.incentive_config.create({
     *   data: {
     *     // ... data to create a Incentive_config
     *   }
     * })
     * 
     */
    create<T extends incentive_configCreateArgs>(args: SelectSubset<T, incentive_configCreateArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incentive_configs.
     * @param {incentive_configCreateManyArgs} args - Arguments to create many Incentive_configs.
     * @example
     * // Create many Incentive_configs
     * const incentive_config = await prisma.incentive_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends incentive_configCreateManyArgs>(args?: SelectSubset<T, incentive_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incentive_configs and returns the data saved in the database.
     * @param {incentive_configCreateManyAndReturnArgs} args - Arguments to create many Incentive_configs.
     * @example
     * // Create many Incentive_configs
     * const incentive_config = await prisma.incentive_config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incentive_configs and only return the `key`
     * const incentive_configWithKeyOnly = await prisma.incentive_config.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends incentive_configCreateManyAndReturnArgs>(args?: SelectSubset<T, incentive_configCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incentive_config.
     * @param {incentive_configDeleteArgs} args - Arguments to delete one Incentive_config.
     * @example
     * // Delete one Incentive_config
     * const Incentive_config = await prisma.incentive_config.delete({
     *   where: {
     *     // ... filter to delete one Incentive_config
     *   }
     * })
     * 
     */
    delete<T extends incentive_configDeleteArgs>(args: SelectSubset<T, incentive_configDeleteArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incentive_config.
     * @param {incentive_configUpdateArgs} args - Arguments to update one Incentive_config.
     * @example
     * // Update one Incentive_config
     * const incentive_config = await prisma.incentive_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends incentive_configUpdateArgs>(args: SelectSubset<T, incentive_configUpdateArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incentive_configs.
     * @param {incentive_configDeleteManyArgs} args - Arguments to filter Incentive_configs to delete.
     * @example
     * // Delete a few Incentive_configs
     * const { count } = await prisma.incentive_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends incentive_configDeleteManyArgs>(args?: SelectSubset<T, incentive_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incentive_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentive_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incentive_configs
     * const incentive_config = await prisma.incentive_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends incentive_configUpdateManyArgs>(args: SelectSubset<T, incentive_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incentive_config.
     * @param {incentive_configUpsertArgs} args - Arguments to update or create a Incentive_config.
     * @example
     * // Update or create a Incentive_config
     * const incentive_config = await prisma.incentive_config.upsert({
     *   create: {
     *     // ... data to create a Incentive_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incentive_config we want to update
     *   }
     * })
     */
    upsert<T extends incentive_configUpsertArgs>(args: SelectSubset<T, incentive_configUpsertArgs<ExtArgs>>): Prisma__incentive_configClient<$Result.GetResult<Prisma.$incentive_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incentive_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentive_configCountArgs} args - Arguments to filter Incentive_configs to count.
     * @example
     * // Count the number of Incentive_configs
     * const count = await prisma.incentive_config.count({
     *   where: {
     *     // ... the filter for the Incentive_configs we want to count
     *   }
     * })
    **/
    count<T extends incentive_configCountArgs>(
      args?: Subset<T, incentive_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Incentive_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incentive_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Incentive_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Incentive_configAggregateArgs>(args: Subset<T, Incentive_configAggregateArgs>): Prisma.PrismaPromise<GetIncentive_configAggregateType<T>>

    /**
     * Group by Incentive_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incentive_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends incentive_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: incentive_configGroupByArgs['orderBy'] }
        : { orderBy?: incentive_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, incentive_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncentive_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the incentive_config model
   */
  readonly fields: incentive_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for incentive_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__incentive_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the incentive_config model
   */ 
  interface incentive_configFieldRefs {
    readonly key: FieldRef<"incentive_config", 'String'>
    readonly value: FieldRef<"incentive_config", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * incentive_config findUnique
   */
  export type incentive_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * Filter, which incentive_config to fetch.
     */
    where: incentive_configWhereUniqueInput
  }

  /**
   * incentive_config findUniqueOrThrow
   */
  export type incentive_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * Filter, which incentive_config to fetch.
     */
    where: incentive_configWhereUniqueInput
  }

  /**
   * incentive_config findFirst
   */
  export type incentive_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * Filter, which incentive_config to fetch.
     */
    where?: incentive_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentive_configs to fetch.
     */
    orderBy?: incentive_configOrderByWithRelationInput | incentive_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incentive_configs.
     */
    cursor?: incentive_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentive_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentive_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incentive_configs.
     */
    distinct?: Incentive_configScalarFieldEnum | Incentive_configScalarFieldEnum[]
  }

  /**
   * incentive_config findFirstOrThrow
   */
  export type incentive_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * Filter, which incentive_config to fetch.
     */
    where?: incentive_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentive_configs to fetch.
     */
    orderBy?: incentive_configOrderByWithRelationInput | incentive_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incentive_configs.
     */
    cursor?: incentive_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentive_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentive_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incentive_configs.
     */
    distinct?: Incentive_configScalarFieldEnum | Incentive_configScalarFieldEnum[]
  }

  /**
   * incentive_config findMany
   */
  export type incentive_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * Filter, which incentive_configs to fetch.
     */
    where?: incentive_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incentive_configs to fetch.
     */
    orderBy?: incentive_configOrderByWithRelationInput | incentive_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing incentive_configs.
     */
    cursor?: incentive_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incentive_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incentive_configs.
     */
    skip?: number
    distinct?: Incentive_configScalarFieldEnum | Incentive_configScalarFieldEnum[]
  }

  /**
   * incentive_config create
   */
  export type incentive_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * The data needed to create a incentive_config.
     */
    data: XOR<incentive_configCreateInput, incentive_configUncheckedCreateInput>
  }

  /**
   * incentive_config createMany
   */
  export type incentive_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many incentive_configs.
     */
    data: incentive_configCreateManyInput | incentive_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * incentive_config createManyAndReturn
   */
  export type incentive_configCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many incentive_configs.
     */
    data: incentive_configCreateManyInput | incentive_configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * incentive_config update
   */
  export type incentive_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * The data needed to update a incentive_config.
     */
    data: XOR<incentive_configUpdateInput, incentive_configUncheckedUpdateInput>
    /**
     * Choose, which incentive_config to update.
     */
    where: incentive_configWhereUniqueInput
  }

  /**
   * incentive_config updateMany
   */
  export type incentive_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update incentive_configs.
     */
    data: XOR<incentive_configUpdateManyMutationInput, incentive_configUncheckedUpdateManyInput>
    /**
     * Filter which incentive_configs to update
     */
    where?: incentive_configWhereInput
  }

  /**
   * incentive_config upsert
   */
  export type incentive_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * The filter to search for the incentive_config to update in case it exists.
     */
    where: incentive_configWhereUniqueInput
    /**
     * In case the incentive_config found by the `where` argument doesn't exist, create a new incentive_config with this data.
     */
    create: XOR<incentive_configCreateInput, incentive_configUncheckedCreateInput>
    /**
     * In case the incentive_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<incentive_configUpdateInput, incentive_configUncheckedUpdateInput>
  }

  /**
   * incentive_config delete
   */
  export type incentive_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
    /**
     * Filter which incentive_config to delete.
     */
    where: incentive_configWhereUniqueInput
  }

  /**
   * incentive_config deleteMany
   */
  export type incentive_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which incentive_configs to delete
     */
    where?: incentive_configWhereInput
  }

  /**
   * incentive_config without action
   */
  export type incentive_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incentive_config
     */
    select?: incentive_configSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Community_partnersScalarFieldEnum: {
    cp_id: 'cp_id',
    name: 'name',
    email: 'email',
    mobile: 'mobile',
    status: 'status',
    aoo: 'aoo',
    created_at: 'created_at'
  };

  export type Community_partnersScalarFieldEnum = (typeof Community_partnersScalarFieldEnum)[keyof typeof Community_partnersScalarFieldEnum]


  export const Cp_applicationsScalarFieldEnum: {
    application_id: 'application_id',
    cp_id: 'cp_id',
    application_data: 'application_data',
    status: 'status',
    reviewed_by: 'reviewed_by',
    reviewed_at: 'reviewed_at',
    created_at: 'created_at'
  };

  export type Cp_applicationsScalarFieldEnum = (typeof Cp_applicationsScalarFieldEnum)[keyof typeof Cp_applicationsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    email: 'email',
    password: 'password',
    role: 'role',
    cp_id: 'cp_id',
    created_at: 'created_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Cp_leadsScalarFieldEnum: {
    lead_id: 'lead_id',
    cp_id: 'cp_id',
    church_name: 'church_name',
    location: 'location',
    stage: 'stage',
    notes: 'notes',
    last_updated: 'last_updated'
  };

  export type Cp_leadsScalarFieldEnum = (typeof Cp_leadsScalarFieldEnum)[keyof typeof Cp_leadsScalarFieldEnum]


  export const IncentivesScalarFieldEnum: {
    incentive_id: 'incentive_id',
    cp_id: 'cp_id',
    lead_id: 'lead_id',
    amount: 'amount',
    status: 'status'
  };

  export type IncentivesScalarFieldEnum = (typeof IncentivesScalarFieldEnum)[keyof typeof IncentivesScalarFieldEnum]


  export const Incentive_configScalarFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type Incentive_configScalarFieldEnum = (typeof Incentive_configScalarFieldEnum)[keyof typeof Incentive_configScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'CpStatus'
   */
  export type EnumCpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CpStatus'>
    


  /**
   * Reference to a field of type 'CpStatus[]'
   */
  export type ListEnumCpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CpStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CpApplicationStatus'
   */
  export type EnumCpApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CpApplicationStatus'>
    


  /**
   * Reference to a field of type 'CpApplicationStatus[]'
   */
  export type ListEnumCpApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CpApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type community_partnersWhereInput = {
    AND?: community_partnersWhereInput | community_partnersWhereInput[]
    OR?: community_partnersWhereInput[]
    NOT?: community_partnersWhereInput | community_partnersWhereInput[]
    cp_id?: StringFilter<"community_partners"> | string
    name?: StringFilter<"community_partners"> | string
    email?: StringFilter<"community_partners"> | string
    mobile?: StringFilter<"community_partners"> | string
    status?: EnumCpStatusFilter<"community_partners"> | $Enums.CpStatus
    aoo?: JsonNullableFilter<"community_partners">
    created_at?: DateTimeFilter<"community_partners"> | Date | string
    cp_applications?: Cp_applicationsListRelationFilter
  }

  export type community_partnersOrderByWithRelationInput = {
    cp_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    status?: SortOrder
    aoo?: SortOrderInput | SortOrder
    created_at?: SortOrder
    cp_applications?: cp_applicationsOrderByRelationAggregateInput
  }

  export type community_partnersWhereUniqueInput = Prisma.AtLeast<{
    cp_id?: string
    email?: string
    AND?: community_partnersWhereInput | community_partnersWhereInput[]
    OR?: community_partnersWhereInput[]
    NOT?: community_partnersWhereInput | community_partnersWhereInput[]
    name?: StringFilter<"community_partners"> | string
    mobile?: StringFilter<"community_partners"> | string
    status?: EnumCpStatusFilter<"community_partners"> | $Enums.CpStatus
    aoo?: JsonNullableFilter<"community_partners">
    created_at?: DateTimeFilter<"community_partners"> | Date | string
    cp_applications?: Cp_applicationsListRelationFilter
  }, "cp_id" | "email">

  export type community_partnersOrderByWithAggregationInput = {
    cp_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    status?: SortOrder
    aoo?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: community_partnersCountOrderByAggregateInput
    _max?: community_partnersMaxOrderByAggregateInput
    _min?: community_partnersMinOrderByAggregateInput
  }

  export type community_partnersScalarWhereWithAggregatesInput = {
    AND?: community_partnersScalarWhereWithAggregatesInput | community_partnersScalarWhereWithAggregatesInput[]
    OR?: community_partnersScalarWhereWithAggregatesInput[]
    NOT?: community_partnersScalarWhereWithAggregatesInput | community_partnersScalarWhereWithAggregatesInput[]
    cp_id?: StringWithAggregatesFilter<"community_partners"> | string
    name?: StringWithAggregatesFilter<"community_partners"> | string
    email?: StringWithAggregatesFilter<"community_partners"> | string
    mobile?: StringWithAggregatesFilter<"community_partners"> | string
    status?: EnumCpStatusWithAggregatesFilter<"community_partners"> | $Enums.CpStatus
    aoo?: JsonNullableWithAggregatesFilter<"community_partners">
    created_at?: DateTimeWithAggregatesFilter<"community_partners"> | Date | string
  }

  export type cp_applicationsWhereInput = {
    AND?: cp_applicationsWhereInput | cp_applicationsWhereInput[]
    OR?: cp_applicationsWhereInput[]
    NOT?: cp_applicationsWhereInput | cp_applicationsWhereInput[]
    application_id?: StringFilter<"cp_applications"> | string
    cp_id?: StringFilter<"cp_applications"> | string
    application_data?: JsonFilter<"cp_applications">
    status?: EnumCpApplicationStatusFilter<"cp_applications"> | $Enums.CpApplicationStatus
    reviewed_by?: StringNullableFilter<"cp_applications"> | string | null
    reviewed_at?: DateTimeNullableFilter<"cp_applications"> | Date | string | null
    created_at?: DateTimeFilter<"cp_applications"> | Date | string
    cp?: XOR<Community_partnersRelationFilter, community_partnersWhereInput>
  }

  export type cp_applicationsOrderByWithRelationInput = {
    application_id?: SortOrder
    cp_id?: SortOrder
    application_data?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    reviewed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    cp?: community_partnersOrderByWithRelationInput
  }

  export type cp_applicationsWhereUniqueInput = Prisma.AtLeast<{
    application_id?: string
    AND?: cp_applicationsWhereInput | cp_applicationsWhereInput[]
    OR?: cp_applicationsWhereInput[]
    NOT?: cp_applicationsWhereInput | cp_applicationsWhereInput[]
    cp_id?: StringFilter<"cp_applications"> | string
    application_data?: JsonFilter<"cp_applications">
    status?: EnumCpApplicationStatusFilter<"cp_applications"> | $Enums.CpApplicationStatus
    reviewed_by?: StringNullableFilter<"cp_applications"> | string | null
    reviewed_at?: DateTimeNullableFilter<"cp_applications"> | Date | string | null
    created_at?: DateTimeFilter<"cp_applications"> | Date | string
    cp?: XOR<Community_partnersRelationFilter, community_partnersWhereInput>
  }, "application_id">

  export type cp_applicationsOrderByWithAggregationInput = {
    application_id?: SortOrder
    cp_id?: SortOrder
    application_data?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    reviewed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: cp_applicationsCountOrderByAggregateInput
    _max?: cp_applicationsMaxOrderByAggregateInput
    _min?: cp_applicationsMinOrderByAggregateInput
  }

  export type cp_applicationsScalarWhereWithAggregatesInput = {
    AND?: cp_applicationsScalarWhereWithAggregatesInput | cp_applicationsScalarWhereWithAggregatesInput[]
    OR?: cp_applicationsScalarWhereWithAggregatesInput[]
    NOT?: cp_applicationsScalarWhereWithAggregatesInput | cp_applicationsScalarWhereWithAggregatesInput[]
    application_id?: StringWithAggregatesFilter<"cp_applications"> | string
    cp_id?: StringWithAggregatesFilter<"cp_applications"> | string
    application_data?: JsonWithAggregatesFilter<"cp_applications">
    status?: EnumCpApplicationStatusWithAggregatesFilter<"cp_applications"> | $Enums.CpApplicationStatus
    reviewed_by?: StringNullableWithAggregatesFilter<"cp_applications"> | string | null
    reviewed_at?: DateTimeNullableWithAggregatesFilter<"cp_applications"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"cp_applications"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    cp_id?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    cp_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    cp_id?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }, "user_id" | "email">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    cp_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    role?: StringWithAggregatesFilter<"users"> | string
    cp_id?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type cp_leadsWhereInput = {
    AND?: cp_leadsWhereInput | cp_leadsWhereInput[]
    OR?: cp_leadsWhereInput[]
    NOT?: cp_leadsWhereInput | cp_leadsWhereInput[]
    lead_id?: StringFilter<"cp_leads"> | string
    cp_id?: StringFilter<"cp_leads"> | string
    church_name?: StringFilter<"cp_leads"> | string
    location?: StringFilter<"cp_leads"> | string
    stage?: StringFilter<"cp_leads"> | string
    notes?: StringNullableFilter<"cp_leads"> | string | null
    last_updated?: DateTimeFilter<"cp_leads"> | Date | string
  }

  export type cp_leadsOrderByWithRelationInput = {
    lead_id?: SortOrder
    cp_id?: SortOrder
    church_name?: SortOrder
    location?: SortOrder
    stage?: SortOrder
    notes?: SortOrderInput | SortOrder
    last_updated?: SortOrder
  }

  export type cp_leadsWhereUniqueInput = Prisma.AtLeast<{
    lead_id?: string
    AND?: cp_leadsWhereInput | cp_leadsWhereInput[]
    OR?: cp_leadsWhereInput[]
    NOT?: cp_leadsWhereInput | cp_leadsWhereInput[]
    cp_id?: StringFilter<"cp_leads"> | string
    church_name?: StringFilter<"cp_leads"> | string
    location?: StringFilter<"cp_leads"> | string
    stage?: StringFilter<"cp_leads"> | string
    notes?: StringNullableFilter<"cp_leads"> | string | null
    last_updated?: DateTimeFilter<"cp_leads"> | Date | string
  }, "lead_id">

  export type cp_leadsOrderByWithAggregationInput = {
    lead_id?: SortOrder
    cp_id?: SortOrder
    church_name?: SortOrder
    location?: SortOrder
    stage?: SortOrder
    notes?: SortOrderInput | SortOrder
    last_updated?: SortOrder
    _count?: cp_leadsCountOrderByAggregateInput
    _max?: cp_leadsMaxOrderByAggregateInput
    _min?: cp_leadsMinOrderByAggregateInput
  }

  export type cp_leadsScalarWhereWithAggregatesInput = {
    AND?: cp_leadsScalarWhereWithAggregatesInput | cp_leadsScalarWhereWithAggregatesInput[]
    OR?: cp_leadsScalarWhereWithAggregatesInput[]
    NOT?: cp_leadsScalarWhereWithAggregatesInput | cp_leadsScalarWhereWithAggregatesInput[]
    lead_id?: StringWithAggregatesFilter<"cp_leads"> | string
    cp_id?: StringWithAggregatesFilter<"cp_leads"> | string
    church_name?: StringWithAggregatesFilter<"cp_leads"> | string
    location?: StringWithAggregatesFilter<"cp_leads"> | string
    stage?: StringWithAggregatesFilter<"cp_leads"> | string
    notes?: StringNullableWithAggregatesFilter<"cp_leads"> | string | null
    last_updated?: DateTimeWithAggregatesFilter<"cp_leads"> | Date | string
  }

  export type incentivesWhereInput = {
    AND?: incentivesWhereInput | incentivesWhereInput[]
    OR?: incentivesWhereInput[]
    NOT?: incentivesWhereInput | incentivesWhereInput[]
    incentive_id?: StringFilter<"incentives"> | string
    cp_id?: StringFilter<"incentives"> | string
    lead_id?: StringFilter<"incentives"> | string
    amount?: IntFilter<"incentives"> | number
    status?: StringFilter<"incentives"> | string
  }

  export type incentivesOrderByWithRelationInput = {
    incentive_id?: SortOrder
    cp_id?: SortOrder
    lead_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
  }

  export type incentivesWhereUniqueInput = Prisma.AtLeast<{
    incentive_id?: string
    lead_id?: string
    AND?: incentivesWhereInput | incentivesWhereInput[]
    OR?: incentivesWhereInput[]
    NOT?: incentivesWhereInput | incentivesWhereInput[]
    cp_id?: StringFilter<"incentives"> | string
    amount?: IntFilter<"incentives"> | number
    status?: StringFilter<"incentives"> | string
  }, "incentive_id" | "lead_id">

  export type incentivesOrderByWithAggregationInput = {
    incentive_id?: SortOrder
    cp_id?: SortOrder
    lead_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    _count?: incentivesCountOrderByAggregateInput
    _avg?: incentivesAvgOrderByAggregateInput
    _max?: incentivesMaxOrderByAggregateInput
    _min?: incentivesMinOrderByAggregateInput
    _sum?: incentivesSumOrderByAggregateInput
  }

  export type incentivesScalarWhereWithAggregatesInput = {
    AND?: incentivesScalarWhereWithAggregatesInput | incentivesScalarWhereWithAggregatesInput[]
    OR?: incentivesScalarWhereWithAggregatesInput[]
    NOT?: incentivesScalarWhereWithAggregatesInput | incentivesScalarWhereWithAggregatesInput[]
    incentive_id?: StringWithAggregatesFilter<"incentives"> | string
    cp_id?: StringWithAggregatesFilter<"incentives"> | string
    lead_id?: StringWithAggregatesFilter<"incentives"> | string
    amount?: IntWithAggregatesFilter<"incentives"> | number
    status?: StringWithAggregatesFilter<"incentives"> | string
  }

  export type incentive_configWhereInput = {
    AND?: incentive_configWhereInput | incentive_configWhereInput[]
    OR?: incentive_configWhereInput[]
    NOT?: incentive_configWhereInput | incentive_configWhereInput[]
    key?: StringFilter<"incentive_config"> | string
    value?: IntFilter<"incentive_config"> | number
  }

  export type incentive_configOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type incentive_configWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: incentive_configWhereInput | incentive_configWhereInput[]
    OR?: incentive_configWhereInput[]
    NOT?: incentive_configWhereInput | incentive_configWhereInput[]
    value?: IntFilter<"incentive_config"> | number
  }, "key">

  export type incentive_configOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    _count?: incentive_configCountOrderByAggregateInput
    _avg?: incentive_configAvgOrderByAggregateInput
    _max?: incentive_configMaxOrderByAggregateInput
    _min?: incentive_configMinOrderByAggregateInput
    _sum?: incentive_configSumOrderByAggregateInput
  }

  export type incentive_configScalarWhereWithAggregatesInput = {
    AND?: incentive_configScalarWhereWithAggregatesInput | incentive_configScalarWhereWithAggregatesInput[]
    OR?: incentive_configScalarWhereWithAggregatesInput[]
    NOT?: incentive_configScalarWhereWithAggregatesInput | incentive_configScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"incentive_config"> | string
    value?: IntWithAggregatesFilter<"incentive_config"> | number
  }

  export type community_partnersCreateInput = {
    cp_id: string
    name: string
    email: string
    mobile: string
    status: $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    cp_applications?: cp_applicationsCreateNestedManyWithoutCpInput
  }

  export type community_partnersUncheckedCreateInput = {
    cp_id: string
    name: string
    email: string
    mobile: string
    status: $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    cp_applications?: cp_applicationsUncheckedCreateNestedManyWithoutCpInput
  }

  export type community_partnersUpdateInput = {
    cp_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    status?: EnumCpStatusFieldUpdateOperationsInput | $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cp_applications?: cp_applicationsUpdateManyWithoutCpNestedInput
  }

  export type community_partnersUncheckedUpdateInput = {
    cp_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    status?: EnumCpStatusFieldUpdateOperationsInput | $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cp_applications?: cp_applicationsUncheckedUpdateManyWithoutCpNestedInput
  }

  export type community_partnersCreateManyInput = {
    cp_id: string
    name: string
    email: string
    mobile: string
    status: $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type community_partnersUpdateManyMutationInput = {
    cp_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    status?: EnumCpStatusFieldUpdateOperationsInput | $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type community_partnersUncheckedUpdateManyInput = {
    cp_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    status?: EnumCpStatusFieldUpdateOperationsInput | $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_applicationsCreateInput = {
    application_id: string
    application_data: JsonNullValueInput | InputJsonValue
    status: $Enums.CpApplicationStatus
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    created_at?: Date | string
    cp: community_partnersCreateNestedOneWithoutCp_applicationsInput
  }

  export type cp_applicationsUncheckedCreateInput = {
    application_id: string
    cp_id: string
    application_data: JsonNullValueInput | InputJsonValue
    status: $Enums.CpApplicationStatus
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    created_at?: Date | string
  }

  export type cp_applicationsUpdateInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_data?: JsonNullValueInput | InputJsonValue
    status?: EnumCpApplicationStatusFieldUpdateOperationsInput | $Enums.CpApplicationStatus
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cp?: community_partnersUpdateOneRequiredWithoutCp_applicationsNestedInput
  }

  export type cp_applicationsUncheckedUpdateInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    application_data?: JsonNullValueInput | InputJsonValue
    status?: EnumCpApplicationStatusFieldUpdateOperationsInput | $Enums.CpApplicationStatus
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_applicationsCreateManyInput = {
    application_id: string
    cp_id: string
    application_data: JsonNullValueInput | InputJsonValue
    status: $Enums.CpApplicationStatus
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    created_at?: Date | string
  }

  export type cp_applicationsUpdateManyMutationInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_data?: JsonNullValueInput | InputJsonValue
    status?: EnumCpApplicationStatusFieldUpdateOperationsInput | $Enums.CpApplicationStatus
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_applicationsUncheckedUpdateManyInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    application_data?: JsonNullValueInput | InputJsonValue
    status?: EnumCpApplicationStatusFieldUpdateOperationsInput | $Enums.CpApplicationStatus
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    user_id: string
    email: string
    password: string
    role: string
    cp_id?: string | null
    created_at?: Date | string | null
  }

  export type usersUncheckedCreateInput = {
    user_id: string
    email: string
    password: string
    role: string
    cp_id?: string | null
    created_at?: Date | string | null
  }

  export type usersUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    cp_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    cp_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyInput = {
    user_id: string
    email: string
    password: string
    role: string
    cp_id?: string | null
    created_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    cp_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    cp_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cp_leadsCreateInput = {
    lead_id: string
    cp_id: string
    church_name: string
    location: string
    stage: string
    notes?: string | null
    last_updated?: Date | string
  }

  export type cp_leadsUncheckedCreateInput = {
    lead_id: string
    cp_id: string
    church_name: string
    location: string
    stage: string
    notes?: string | null
    last_updated?: Date | string
  }

  export type cp_leadsUpdateInput = {
    lead_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    church_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_leadsUncheckedUpdateInput = {
    lead_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    church_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_leadsCreateManyInput = {
    lead_id: string
    cp_id: string
    church_name: string
    location: string
    stage: string
    notes?: string | null
    last_updated?: Date | string
  }

  export type cp_leadsUpdateManyMutationInput = {
    lead_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    church_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_leadsUncheckedUpdateManyInput = {
    lead_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    church_name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incentivesCreateInput = {
    incentive_id: string
    cp_id: string
    lead_id: string
    amount: number
    status: string
  }

  export type incentivesUncheckedCreateInput = {
    incentive_id: string
    cp_id: string
    lead_id: string
    amount: number
    status: string
  }

  export type incentivesUpdateInput = {
    incentive_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    lead_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type incentivesUncheckedUpdateInput = {
    incentive_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    lead_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type incentivesCreateManyInput = {
    incentive_id: string
    cp_id: string
    lead_id: string
    amount: number
    status: string
  }

  export type incentivesUpdateManyMutationInput = {
    incentive_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    lead_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type incentivesUncheckedUpdateManyInput = {
    incentive_id?: StringFieldUpdateOperationsInput | string
    cp_id?: StringFieldUpdateOperationsInput | string
    lead_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type incentive_configCreateInput = {
    key: string
    value: number
  }

  export type incentive_configUncheckedCreateInput = {
    key: string
    value: number
  }

  export type incentive_configUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type incentive_configUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type incentive_configCreateManyInput = {
    key: string
    value: number
  }

  export type incentive_configUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type incentive_configUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumCpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CpStatus | EnumCpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpStatusFilter<$PrismaModel> | $Enums.CpStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Cp_applicationsListRelationFilter = {
    every?: cp_applicationsWhereInput
    some?: cp_applicationsWhereInput
    none?: cp_applicationsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type cp_applicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type community_partnersCountOrderByAggregateInput = {
    cp_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    status?: SortOrder
    aoo?: SortOrder
    created_at?: SortOrder
  }

  export type community_partnersMaxOrderByAggregateInput = {
    cp_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type community_partnersMinOrderByAggregateInput = {
    cp_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumCpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CpStatus | EnumCpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpStatusWithAggregatesFilter<$PrismaModel> | $Enums.CpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCpStatusFilter<$PrismaModel>
    _max?: NestedEnumCpStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumCpApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CpApplicationStatus | EnumCpApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpApplicationStatusFilter<$PrismaModel> | $Enums.CpApplicationStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Community_partnersRelationFilter = {
    is?: community_partnersWhereInput
    isNot?: community_partnersWhereInput
  }

  export type cp_applicationsCountOrderByAggregateInput = {
    application_id?: SortOrder
    cp_id?: SortOrder
    application_data?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    reviewed_at?: SortOrder
    created_at?: SortOrder
  }

  export type cp_applicationsMaxOrderByAggregateInput = {
    application_id?: SortOrder
    cp_id?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    reviewed_at?: SortOrder
    created_at?: SortOrder
  }

  export type cp_applicationsMinOrderByAggregateInput = {
    application_id?: SortOrder
    cp_id?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    reviewed_at?: SortOrder
    created_at?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumCpApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CpApplicationStatus | EnumCpApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CpApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCpApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumCpApplicationStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    cp_id?: SortOrder
    created_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    cp_id?: SortOrder
    created_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    cp_id?: SortOrder
    created_at?: SortOrder
  }

  export type cp_leadsCountOrderByAggregateInput = {
    lead_id?: SortOrder
    cp_id?: SortOrder
    church_name?: SortOrder
    location?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    last_updated?: SortOrder
  }

  export type cp_leadsMaxOrderByAggregateInput = {
    lead_id?: SortOrder
    cp_id?: SortOrder
    church_name?: SortOrder
    location?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    last_updated?: SortOrder
  }

  export type cp_leadsMinOrderByAggregateInput = {
    lead_id?: SortOrder
    cp_id?: SortOrder
    church_name?: SortOrder
    location?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    last_updated?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type incentivesCountOrderByAggregateInput = {
    incentive_id?: SortOrder
    cp_id?: SortOrder
    lead_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
  }

  export type incentivesAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type incentivesMaxOrderByAggregateInput = {
    incentive_id?: SortOrder
    cp_id?: SortOrder
    lead_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
  }

  export type incentivesMinOrderByAggregateInput = {
    incentive_id?: SortOrder
    cp_id?: SortOrder
    lead_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
  }

  export type incentivesSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type incentive_configCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type incentive_configAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type incentive_configMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type incentive_configMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type incentive_configSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type cp_applicationsCreateNestedManyWithoutCpInput = {
    create?: XOR<cp_applicationsCreateWithoutCpInput, cp_applicationsUncheckedCreateWithoutCpInput> | cp_applicationsCreateWithoutCpInput[] | cp_applicationsUncheckedCreateWithoutCpInput[]
    connectOrCreate?: cp_applicationsCreateOrConnectWithoutCpInput | cp_applicationsCreateOrConnectWithoutCpInput[]
    createMany?: cp_applicationsCreateManyCpInputEnvelope
    connect?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
  }

  export type cp_applicationsUncheckedCreateNestedManyWithoutCpInput = {
    create?: XOR<cp_applicationsCreateWithoutCpInput, cp_applicationsUncheckedCreateWithoutCpInput> | cp_applicationsCreateWithoutCpInput[] | cp_applicationsUncheckedCreateWithoutCpInput[]
    connectOrCreate?: cp_applicationsCreateOrConnectWithoutCpInput | cp_applicationsCreateOrConnectWithoutCpInput[]
    createMany?: cp_applicationsCreateManyCpInputEnvelope
    connect?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumCpStatusFieldUpdateOperationsInput = {
    set?: $Enums.CpStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type cp_applicationsUpdateManyWithoutCpNestedInput = {
    create?: XOR<cp_applicationsCreateWithoutCpInput, cp_applicationsUncheckedCreateWithoutCpInput> | cp_applicationsCreateWithoutCpInput[] | cp_applicationsUncheckedCreateWithoutCpInput[]
    connectOrCreate?: cp_applicationsCreateOrConnectWithoutCpInput | cp_applicationsCreateOrConnectWithoutCpInput[]
    upsert?: cp_applicationsUpsertWithWhereUniqueWithoutCpInput | cp_applicationsUpsertWithWhereUniqueWithoutCpInput[]
    createMany?: cp_applicationsCreateManyCpInputEnvelope
    set?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    disconnect?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    delete?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    connect?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    update?: cp_applicationsUpdateWithWhereUniqueWithoutCpInput | cp_applicationsUpdateWithWhereUniqueWithoutCpInput[]
    updateMany?: cp_applicationsUpdateManyWithWhereWithoutCpInput | cp_applicationsUpdateManyWithWhereWithoutCpInput[]
    deleteMany?: cp_applicationsScalarWhereInput | cp_applicationsScalarWhereInput[]
  }

  export type cp_applicationsUncheckedUpdateManyWithoutCpNestedInput = {
    create?: XOR<cp_applicationsCreateWithoutCpInput, cp_applicationsUncheckedCreateWithoutCpInput> | cp_applicationsCreateWithoutCpInput[] | cp_applicationsUncheckedCreateWithoutCpInput[]
    connectOrCreate?: cp_applicationsCreateOrConnectWithoutCpInput | cp_applicationsCreateOrConnectWithoutCpInput[]
    upsert?: cp_applicationsUpsertWithWhereUniqueWithoutCpInput | cp_applicationsUpsertWithWhereUniqueWithoutCpInput[]
    createMany?: cp_applicationsCreateManyCpInputEnvelope
    set?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    disconnect?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    delete?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    connect?: cp_applicationsWhereUniqueInput | cp_applicationsWhereUniqueInput[]
    update?: cp_applicationsUpdateWithWhereUniqueWithoutCpInput | cp_applicationsUpdateWithWhereUniqueWithoutCpInput[]
    updateMany?: cp_applicationsUpdateManyWithWhereWithoutCpInput | cp_applicationsUpdateManyWithWhereWithoutCpInput[]
    deleteMany?: cp_applicationsScalarWhereInput | cp_applicationsScalarWhereInput[]
  }

  export type community_partnersCreateNestedOneWithoutCp_applicationsInput = {
    create?: XOR<community_partnersCreateWithoutCp_applicationsInput, community_partnersUncheckedCreateWithoutCp_applicationsInput>
    connectOrCreate?: community_partnersCreateOrConnectWithoutCp_applicationsInput
    connect?: community_partnersWhereUniqueInput
  }

  export type EnumCpApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.CpApplicationStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type community_partnersUpdateOneRequiredWithoutCp_applicationsNestedInput = {
    create?: XOR<community_partnersCreateWithoutCp_applicationsInput, community_partnersUncheckedCreateWithoutCp_applicationsInput>
    connectOrCreate?: community_partnersCreateOrConnectWithoutCp_applicationsInput
    upsert?: community_partnersUpsertWithoutCp_applicationsInput
    connect?: community_partnersWhereUniqueInput
    update?: XOR<XOR<community_partnersUpdateToOneWithWhereWithoutCp_applicationsInput, community_partnersUpdateWithoutCp_applicationsInput>, community_partnersUncheckedUpdateWithoutCp_applicationsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumCpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CpStatus | EnumCpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpStatusFilter<$PrismaModel> | $Enums.CpStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumCpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CpStatus | EnumCpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpStatus[] | ListEnumCpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpStatusWithAggregatesFilter<$PrismaModel> | $Enums.CpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCpStatusFilter<$PrismaModel>
    _max?: NestedEnumCpStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCpApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CpApplicationStatus | EnumCpApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpApplicationStatusFilter<$PrismaModel> | $Enums.CpApplicationStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCpApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CpApplicationStatus | EnumCpApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CpApplicationStatus[] | ListEnumCpApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCpApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CpApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCpApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumCpApplicationStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type cp_applicationsCreateWithoutCpInput = {
    application_id: string
    application_data: JsonNullValueInput | InputJsonValue
    status: $Enums.CpApplicationStatus
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    created_at?: Date | string
  }

  export type cp_applicationsUncheckedCreateWithoutCpInput = {
    application_id: string
    application_data: JsonNullValueInput | InputJsonValue
    status: $Enums.CpApplicationStatus
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    created_at?: Date | string
  }

  export type cp_applicationsCreateOrConnectWithoutCpInput = {
    where: cp_applicationsWhereUniqueInput
    create: XOR<cp_applicationsCreateWithoutCpInput, cp_applicationsUncheckedCreateWithoutCpInput>
  }

  export type cp_applicationsCreateManyCpInputEnvelope = {
    data: cp_applicationsCreateManyCpInput | cp_applicationsCreateManyCpInput[]
    skipDuplicates?: boolean
  }

  export type cp_applicationsUpsertWithWhereUniqueWithoutCpInput = {
    where: cp_applicationsWhereUniqueInput
    update: XOR<cp_applicationsUpdateWithoutCpInput, cp_applicationsUncheckedUpdateWithoutCpInput>
    create: XOR<cp_applicationsCreateWithoutCpInput, cp_applicationsUncheckedCreateWithoutCpInput>
  }

  export type cp_applicationsUpdateWithWhereUniqueWithoutCpInput = {
    where: cp_applicationsWhereUniqueInput
    data: XOR<cp_applicationsUpdateWithoutCpInput, cp_applicationsUncheckedUpdateWithoutCpInput>
  }

  export type cp_applicationsUpdateManyWithWhereWithoutCpInput = {
    where: cp_applicationsScalarWhereInput
    data: XOR<cp_applicationsUpdateManyMutationInput, cp_applicationsUncheckedUpdateManyWithoutCpInput>
  }

  export type cp_applicationsScalarWhereInput = {
    AND?: cp_applicationsScalarWhereInput | cp_applicationsScalarWhereInput[]
    OR?: cp_applicationsScalarWhereInput[]
    NOT?: cp_applicationsScalarWhereInput | cp_applicationsScalarWhereInput[]
    application_id?: StringFilter<"cp_applications"> | string
    cp_id?: StringFilter<"cp_applications"> | string
    application_data?: JsonFilter<"cp_applications">
    status?: EnumCpApplicationStatusFilter<"cp_applications"> | $Enums.CpApplicationStatus
    reviewed_by?: StringNullableFilter<"cp_applications"> | string | null
    reviewed_at?: DateTimeNullableFilter<"cp_applications"> | Date | string | null
    created_at?: DateTimeFilter<"cp_applications"> | Date | string
  }

  export type community_partnersCreateWithoutCp_applicationsInput = {
    cp_id: string
    name: string
    email: string
    mobile: string
    status: $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type community_partnersUncheckedCreateWithoutCp_applicationsInput = {
    cp_id: string
    name: string
    email: string
    mobile: string
    status: $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type community_partnersCreateOrConnectWithoutCp_applicationsInput = {
    where: community_partnersWhereUniqueInput
    create: XOR<community_partnersCreateWithoutCp_applicationsInput, community_partnersUncheckedCreateWithoutCp_applicationsInput>
  }

  export type community_partnersUpsertWithoutCp_applicationsInput = {
    update: XOR<community_partnersUpdateWithoutCp_applicationsInput, community_partnersUncheckedUpdateWithoutCp_applicationsInput>
    create: XOR<community_partnersCreateWithoutCp_applicationsInput, community_partnersUncheckedCreateWithoutCp_applicationsInput>
    where?: community_partnersWhereInput
  }

  export type community_partnersUpdateToOneWithWhereWithoutCp_applicationsInput = {
    where?: community_partnersWhereInput
    data: XOR<community_partnersUpdateWithoutCp_applicationsInput, community_partnersUncheckedUpdateWithoutCp_applicationsInput>
  }

  export type community_partnersUpdateWithoutCp_applicationsInput = {
    cp_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    status?: EnumCpStatusFieldUpdateOperationsInput | $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type community_partnersUncheckedUpdateWithoutCp_applicationsInput = {
    cp_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    status?: EnumCpStatusFieldUpdateOperationsInput | $Enums.CpStatus
    aoo?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_applicationsCreateManyCpInput = {
    application_id: string
    application_data: JsonNullValueInput | InputJsonValue
    status: $Enums.CpApplicationStatus
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    created_at?: Date | string
  }

  export type cp_applicationsUpdateWithoutCpInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_data?: JsonNullValueInput | InputJsonValue
    status?: EnumCpApplicationStatusFieldUpdateOperationsInput | $Enums.CpApplicationStatus
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_applicationsUncheckedUpdateWithoutCpInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_data?: JsonNullValueInput | InputJsonValue
    status?: EnumCpApplicationStatusFieldUpdateOperationsInput | $Enums.CpApplicationStatus
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cp_applicationsUncheckedUpdateManyWithoutCpInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_data?: JsonNullValueInput | InputJsonValue
    status?: EnumCpApplicationStatusFieldUpdateOperationsInput | $Enums.CpApplicationStatus
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Community_partnersCountOutputTypeDefaultArgs instead
     */
    export type Community_partnersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Community_partnersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use community_partnersDefaultArgs instead
     */
    export type community_partnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = community_partnersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cp_applicationsDefaultArgs instead
     */
    export type cp_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cp_applicationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cp_leadsDefaultArgs instead
     */
    export type cp_leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cp_leadsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use incentivesDefaultArgs instead
     */
    export type incentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = incentivesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use incentive_configDefaultArgs instead
     */
    export type incentive_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = incentive_configDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}